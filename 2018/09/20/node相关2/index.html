<!DOCTYPE html>




<html class="theme-next mist" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="node," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="nodenpm 的 package-lock.json 用于锁住依赖的版本号。尤其是项目中依赖包的依赖。以前存在一个问题，package.json 中对依赖包版本进行了限制，但依赖包的依赖的版本限制由依赖包中的 package.json ，项目作者能控制自己依赖包的版本，但不能控制依赖包的依赖包的版本。故出现了 package-lock.json 这个方案。用来锁住一切的版本号。 web 后台中的">
<meta name="keywords" content="node">
<meta property="og:type" content="article">
<meta property="og:title" content="node相关2">
<meta property="og:url" content="http://yoursite.com/2018/09/20/node相关2/index.html">
<meta property="og:site_name" content="Ak-lee">
<meta property="og:description" content="nodenpm 的 package-lock.json 用于锁住依赖的版本号。尤其是项目中依赖包的依赖。以前存在一个问题，package.json 中对依赖包版本进行了限制，但依赖包的依赖的版本限制由依赖包中的 package.json ，项目作者能控制自己依赖包的版本，但不能控制依赖包的依赖包的版本。故出现了 package-lock.json 这个方案。用来锁住一切的版本号。 web 后台中的">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2018-09-20T04:11:17.531Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="node相关2">
<meta name="twitter:description" content="nodenpm 的 package-lock.json 用于锁住依赖的版本号。尤其是项目中依赖包的依赖。以前存在一个问题，package.json 中对依赖包版本进行了限制，但依赖包的依赖的版本限制由依赖包中的 package.json ，项目作者能控制自己依赖包的版本，但不能控制依赖包的依赖包的版本。故出现了 package-lock.json 这个方案。用来锁住一切的版本号。 web 后台中的">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.2',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/09/20/node相关2/"/>





  <title>node相关2 | Ak-lee</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Ak-lee</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">前端修炼中</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/20/node相关2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ak-lee">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ak-lee">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">node相关2</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-09-20T12:10:21+08:00">
                2018-09-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="node"><a href="#node" class="headerlink" title="node"></a>node</h1><p><code>npm</code> 的 <code>package-lock.json</code> 用于锁住依赖的版本号。尤其是项目中依赖包的依赖。以前存在一个问题，<code>package.json</code> 中对依赖包版本进行了限制，但依赖包的依赖的版本限制由依赖包中的 <code>package.json</code> ，项目作者能控制自己依赖包的版本，但不能控制依赖包的依赖包的版本。故出现了 <code>package-lock.json</code> 这个方案。用来锁住一切的版本号。</p>
<p>web 后台中的 <code>MVC</code> 。</p>
<blockquote>
<p>M，负责和数据库交互，抽象出常见接口方便调用</p>
<p>C，控制器，负责路由。控制流向</p>
<p>V，视图，各种模板引擎的模板</p>
</blockquote>
<h3 id="process-env-的小坑"><a href="#process-env-的小坑" class="headerlink" title="process.env 的小坑"></a>process.env 的小坑</h3><p>在 <code>*nix</code> 中，<code>PORT=8080 node xxx.js</code> 在 <code>xxx.js</code> 通过 <code>process.env.PORT</code> 可以拿到这个<code>8080</code> 设置值，但在win电脑下不行。</p>
<p>正确的写法是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// package.json</span></div><div class="line"><span class="string">"scripts"</span>: &#123;</div><div class="line">    <span class="comment">// win</span></div><div class="line">    <span class="string">"start"</span>: <span class="string">"set PORT=4040 &amp;&amp; node xxx.js"</span></div><div class="line">    <span class="comment">// mac</span></div><div class="line">    <span class="comment">// "start": "export PORT=4040 &amp;&amp; node xxx.js"</span></div><div class="line">  &#125;,</div></pre></td></tr></table></figure>
<p><code>export NODE_ENV=production &amp;&amp; node xxx.js</code>  这样在当前命令行下后续的命令中读取 <code>NODE_ENV</code>，都会得到  production 值； 如果直接使用 <code>NODE_ENV=production node xxx.js</code>，则 <code>NODE_ENV</code> 的有效性仅限当前命令，不会对后续命令有影响。 </p>
<p>也可以安装一个 <code>cross-env</code> 的包：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="string">"scripts"</span>: &#123;</div><div class="line">    <span class="string">"start"</span>: <span class="string">"cross-env PORT=4040 &amp;&amp; node xxx.js"</span></div><div class="line">  &#125;,</div></pre></td></tr></table></figure>
<p><strong>在web前端和后端一起联调的时候，前端本身调试有webpack-dev-server, 但是后端本身就是一个server，两者不能结合。所以可以用 onchange 这个包</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">npm install onchange --save-dev</div><div class="line"></div><div class="line">onchange &apos;app/**/*.js&apos; -- npm run webpack</div></pre></td></tr></table></figure>
<p><code>onchange</code> 起到了<code>watch</code> 监视的作用。一检测到文件变化就重新执行后面的那条命令。</p>
<h3 id="node-server"><a href="#node-server" class="headerlink" title="node server"></a>node server</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</div><div class="line"><span class="keyword">const</span> server = http.createServer()</div><div class="line"></div><div class="line">server.on(<span class="string">'request'</span>, (req, res) =&gt; &#123;</div><div class="line">    res.statusCode = <span class="number">200</span></div><div class="line">    res.end(<span class="string">'welcome to my first http server'</span>)</div><div class="line">&#125; )</div><div class="line">server.listen(<span class="number">8080</span>)</div></pre></td></tr></table></figure>
<p>url 的格式: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Schema://host:port/path?query#hash</div></pre></td></tr></table></figure>
<p>常用的端口号：</p>
<blockquote>
<p>22: 用于 ssh 服务</p>
<p>80: 用于 http 服务</p>
<p>443: 用于 https 服务</p>
<p>27017: 用于 mongodb</p>
</blockquote>
<p>解析query：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// querystring 只能解析以？开头的字符串，不能解析整个url</span></div><div class="line"><span class="keyword">const</span> qs = <span class="built_in">require</span>(<span class="string">'querystring'</span>)</div><div class="line"></div><div class="line"><span class="keyword">var</span> query = qs.parse(<span class="string">'?a=1&amp;b=2'</span>)</div></pre></td></tr></table></figure>
<p><code>query</code> 以 <code>&amp;</code> 来分隔不同的键值对，以 <code>=</code> 来分隔键和值</p>
<p><code>cookie</code> 以 <code>;</code> 来分隔不同的键值对， 以 <code>=</code> 来分隔键和值。</p>
<h2 id="Express-项目初始化"><a href="#Express-项目初始化" class="headerlink" title="Express 项目初始化"></a>Express 项目初始化</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">npm i express-generator</div><div class="line"></div><div class="line">express --view=ejs testDir</div><div class="line"></div><div class="line">cd testDir &amp;&amp; npm install</div><div class="line"></div><div class="line">npm start</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</div><div class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</div><div class="line"><span class="keyword">const</span> app = express();</div><div class="line"></div><div class="line">app.use(<span class="string">'/'</span>, (req, res) =&gt; &#123;</div><div class="line">    res.end(<span class="string">'hello my express demo'</span>)</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="keyword">const</span> server = http.createServer(app)</div><div class="line">server.listen(<span class="string">'8080'</span>)</div></pre></td></tr></table></figure>
<p>关于 Express 中间件， 一个值得注意的点：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 回调函数为 2 个参数的情况</span></div><div class="line">app.use(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</div><div class="line">    </div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// 回调函数为 3 个参数的情况</span></div><div class="line">app.use(<span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</div><div class="line">    </div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// 回调函数为 4 个参数的情况</span></div><div class="line">app.use(<span class="function">(<span class="params">err, req, res, next</span>) =&gt;</span> &#123;</div><div class="line">    </div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>错误写法： </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">app.use(<span class="function">(<span class="params">err, req, res</span>)=&gt;</span>&#123;</div><div class="line">    <span class="comment">// 这样是拿不到 err 的。</span></div><div class="line">    <span class="comment">// err 会指向实际的 req，req指向实际的res，res 指向实际的next</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p><code>next()</code> 函数里面可以传参数，作为下一个中间件的 <code>err</code> 参数来接受。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">app.use(<span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</div><div class="line">    next(<span class="string">'something wrong'</span>)</div><div class="line">&#125;)</div><div class="line"></div><div class="line">app.use(<span class="function">(<span class="params">err, req, res, next</span>) =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(err)	<span class="comment">// 打印出 something wrong</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p><code>next()</code> 中传入一个参数会直接作为一个错误被处理掉。</p>
<p><strong>body-parser</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">'body-parser'</span>)</div><div class="line"></div><div class="line">app.use(bodyParser.json())	<span class="comment">// 解析post上来的json数据</span></div><div class="line">app.use(bodyParser.urlencoded(&#123;<span class="attr">extended</span>: <span class="literal">true</span>&#125;))	<span class="comment">// 解析url中query带上来的数据</span></div><div class="line"><span class="comment">// extended: true, 表示是否支持扩展写法。即支持如下写法。</span></div><div class="line"><span class="comment">// 如 users[0]= 'wang'&amp;users[1]='zhang' ，会被解析成： users['wang', 'zhang']</span></div><div class="line"><span class="comment">// user[name]='wang'&amp;user[age]=18, 会被解析成： user：&#123;name：'wang', age: '18'&#125;</span></div></pre></td></tr></table></figure>
<p><strong>Express 中设置模板引擎</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</div><div class="line"><span class="keyword">const</span> app = express();</div><div class="line"></div><div class="line"><span class="comment">// view engine setup</span></div><div class="line">app.set(<span class="string">'views'</span>, path.join(__dirname, <span class="string">'views'</span>))</div><div class="line">app.set(<span class="string">'view engine'</span>, <span class="string">'ejs'</span>)</div></pre></td></tr></table></figure>
<p><strong>如果路径不匹配所有的路径</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</div><div class="line"><span class="keyword">const</span> app = express()</div><div class="line">app.use(<span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">const</span> err = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Not Found'</span>)</div><div class="line">    err.status = <span class="number">404</span>;</div><div class="line">    next(err)</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// error handle</span></div><div class="line">app.use(<span class="function">(<span class="params">err, req, res, next</span>) =&gt;</span> &#123;</div><div class="line">    <span class="comment">// set locals, only providing error in development</span></div><div class="line">    res.locals.message =  err.message</div><div class="line">    res.locals.error = req.app.get(<span class="string">'env'</span>) === <span class="string">'development'</span> ? err : &#123;&#125;</div><div class="line">    <span class="comment">// req.app 即 外层的app, 两者是等价的</span></div><div class="line">    <span class="comment">// app.get('env') 用来获取当前用户环境变量的 NODE_ENV 的值</span></div><div class="line">    <span class="comment">// 上面的那条判断语句可以改写成： process.env.NODE_ENV === ’development‘</span></div><div class="line">    </div><div class="line">    <span class="comment">// render the error pages</span></div><div class="line">    res.status(error.status || <span class="number">400</span>)</div><div class="line">    res.render(<span class="string">'error'</span>)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">next(<span class="string">'router'</span>)</div><div class="line"><span class="comment">// 会终止当前 router，不会进入到下一个中间件。这是一个隐藏的彩蛋</span></div><div class="line"></div><div class="line"><span class="comment">// 如果调用next的时候传入任何值，除了'router'字符串以外，均会触发err中间件,</span></div><div class="line"><span class="comment">// 如果next('router')，则是跳过当前中间件栈的处理流程，</span></div><div class="line"><span class="comment">// 直接进入下一个router中间件中</span></div></pre></td></tr></table></figure>
<h3 id="Express-的-MVC"><a href="#Express-的-MVC" class="headerlink" title="Express 的 MVC"></a>Express 的 MVC</h3><p><code>static</code> 关键字为一个类定义一个静态方法。静态方法不会在类的实例上被调用。相反，它们被类本身调用。这些通常是使用程序方法。例如创建或克隆对象的功能。</p>
<p>静态方法调用直接在类上进行，不能在类的实例上调用。静态方法通常用于创建</p>
<p><strong>Model</strong> 处理数据相关的操作：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// model 文件夹下 user.js 文件</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> users = []</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(firstName, lastName, age)&#123;</div><div class="line">        <span class="keyword">this</span>.firstName = firstName</div><div class="line">        <span class="keyword">this</span>.lastName = lastName</div><div class="line">        <span class="keyword">this</span>.age = ageN</div><div class="line">    &#125;</div><div class="line">    getName()&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="keyword">this</span>.lastName</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">static</span> insert(firstName, lastName, age) &#123;</div><div class="line">        <span class="keyword">const</span> u = <span class="keyword">new</span> User(firstName, lastName, age)</div><div class="line">        User.users.push(u)</div><div class="line">        <span class="keyword">return</span> u</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">static</span> findOneByName(firstName, lastName)&#123;</div><div class="line">        <span class="keyword">return</span> User.users.find(<span class="function">(<span class="params">u</span>) =&gt;</span> &#123;</div><div class="line">            <span class="keyword">return</span> u.firstName === firstName &amp;&amp; u.lastName === lastName</div><div class="line">        &#125;)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">static</span> list(query) &#123;</div><div class="line">        <span class="keyword">return</span> User.users</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">static</span> get [<span class="string">'users'</span>]() &#123;</div><div class="line">        <span class="keyword">return</span> users</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = User</div></pre></td></tr></table></figure>
<p>把既具有一些属性，有提供操作这些属性的方法封装在一起，这就是<code>MVC</code> 中的 <code>M</code> 模块。一个 <strong>Model</strong> 里面只处理一个内容。不同的<strong>Model</strong> 之间不要有耦合。</p>
<p><strong>service</strong> 文件夹下的文件提供对 <strong>Model</strong> 中多个model的操作方法。<strong>service</strong> 有点特别。由于同层的 <strong>Model</strong> 之间解耦的需要，单个 model 往往不应该包含太多对其他model的操作，我们应该在 services 中对一系列逻辑上有关的 model 进行统一操作。即，<strong>Model</strong> 之间需要耦合的部分放在 <strong>service</strong> 中来。</p>
<p>一个 service 负责一个业务，但可能会操作多个model。相当于分担了一部分 controller 的功能。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// user_service.js</span></div><div class="line"><span class="comment">// 这里的 service 只操作了一个 model，以后会有复杂的 service</span></div><div class="line"><span class="keyword">const</span> User = <span class="built_in">require</span>(<span class="string">'../models/user'</span>);</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> User.list()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>Request</strong></p>
<p><code>request.params</code>: 识别定义路径时以冒号开头的参数。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://localhost:3000/user/xiaoming</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">router.get(<span class="string">'/user/:name'</span>, (req, res) =&gt; &#123;</div><div class="line">	<span class="built_in">console</span>.log(req.params.name)    </div><div class="line">	<span class="comment">// 打印出的结果为： xiaoming</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p><code>request.body</code> ：经过 body-parser 转码后的 body 对象</p>
<p><code>request.method</code>: 请求方法</p>
<p><code>request.query</code>: 经过 node 原生 querystring 等生成的对象。</p>
<p><code>request.get</code> : 获取 header</p>
<p><strong>Response</strong></p>
<p><code>response.send</code>: 发送内容</p>
<p><code>response.append</code>： 在响应头中加入内容</p>
<p><code>response.redirect</code>: 重定向请求</p>
<p><code>response.json</code>: 发送 JSON 给客户端</p>
<h2 id="MongoDB-数据库"><a href="#MongoDB-数据库" class="headerlink" title="MongoDB 数据库"></a>MongoDB 数据库</h2><p><code>MongoDB</code>是为快速开发还联网 Web 应用而设计的数据库系统。</p>
<p><strong><code>MongoDB</code> 的数据模型是面向文档的。所谓的文档是一种类似与 JSON 的结构</strong>。简单理解 <code>MongoDB</code> 这个数据库中存的是各种各样的 JSON ( BSON )</p>
<p>输入 <code>mongod</code> 来启动 <code>mongodb</code> 服务器。</p>
<p>数据库：</p>
<blockquote>
<ul>
<li><p>数据库的服务器</p>
<p>服务器用来保存数据。<code>mongod</code> 用来启动服务器。</p>
</li>
<li><p>数据库的客户端</p>
<p>客户端用来操作服务器，对数据进行增删改查的操作。<code>mongo</code> 命令用来启动客户端。</p>
</li>
</ul>
</blockquote>
<p>输入 <code>mongo</code> 来启动 <code>mongodb</code> 的客户端。</p>
<p><code>mongod</code> 服务器启动：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mongod --dbpath ./mongo</div></pre></td></tr></table></figure>
<p>将 <code>MongoDB</code> 设置为系统服务，可以自动在后台启动，不需要每次都手动启动。</p>
<p>manually create a windows service for MongoDB Community Edition</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">// 1.创建目录</div><div class="line">mkdir C:\data\db</div><div class="line">mkdir c:\data\log</div><div class="line"></div><div class="line">// 2. 在 mongodb 软件安装目录下，创建一个配置文件 mongod.cfg 文件。用于配置log的存放路径和数据库的存放路径。</div><div class="line">systemLog:</div><div class="line">    destination: file</div><div class="line">    path: c:\data\log\mongod.log</div><div class="line">storage:</div><div class="line">    dbPath: c:\data\db</div><div class="line"></div><div class="line">// 3.以管理员身份打开命令行窗口，执行如下的命令(注意作路径的替换工作)：</div><div class="line">sc.exe create MongoDB binPath= &quot;\&quot;C:\Program Files\MongoDB\Server\3.4\bin\mongod.exe\&quot; --service --config=\&quot;C:\Program Files\MongoDB\Server\3.4\mongod.cfg\&quot;&quot; DisplayName= &quot;MongoDB&quot; start= &quot;auto&quot;</div><div class="line"></div><div class="line">// 4. 在任务管理器中的服务栏中启动 mongodb 的服务。</div><div class="line">// 5. 如果启动失败，证明上面的操作有误</div><div class="line">	在控制台输入 sc delete MongoDB 删除之前配置的服务。然后从来一次</div></pre></td></tr></table></figure>
<p><strong>三个概念</strong></p>
<blockquote>
<ul>
<li><p>数据库（database）</p>
<p>数据库是一个仓库，在仓库中可以存放集合</p>
</li>
<li><p>集合 （collections）</p>
<p>集合相当于关系型数据库中的表，在集合中可以存放文档。</p>
</li>
<li><p>文档（document）</p>
<p>文档数据库中的最小单位，我们存储和操作的内容都是文档。</p>
</li>
</ul>
</blockquote>
<p>MongoDB 对 32 位系统支持不佳，所以 3.2 版本以后没有再对 32 位系统的支持。</p>
<p>安装好 Mongodb 之后需要把 MongoDB 的 bin 目录添加到 path 环境变量中去。</p>
<p><code>MongoDB</code> 的主键是 <code>ObjectId</code> 。 <code>ObjcectId</code> 是一个与当前时间，当前<code>mongod</code>服务的进程号，运行机器的名称，自增长的一个数字，这几个因素编码后生成的唯一标识。</p>
<p><code>ObjectId</code> 与时间有关系，故 <code>ObjectId</code> 之间可以比较大小，比较的实际上就是创建时间的大小。</p>
<p><code>mongodb</code> 可以保证你任何时候创建的 <code>ObjectId</code> 都是唯一的。可以放心使用。</p>
<blockquote>
<p>show databases: 展示已有的数据库</p>
<p>use 数据库名： 创建并进入该数据库</p>
<p>show collections: 展示已进入的数据库中的表</p>
<p>db: 代表当前已经进入的数据库</p>
<p>db.users.insert({name: “xiaoming”}): 直接通过在表里创建一条记录的方式来创建表。表不存在的话，会自动创建表。</p>
</blockquote>
<p><strong>MongoDB 聚合</strong></p>
<p>MongoDB 中聚合（aggregate） 主要用于处理数据（诸如统计平均值，求和等），并返回计算后的数据结果。</p>
<p>MongoDB 中聚合的方法使用 <code>aggregate()</code> 方法。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">db.users.aggregate([</div><div class="line">    &#123;</div><div class="line">        $match: &#123;</div><div class="line">            age: &#123;</div><div class="line">                $exists: <span class="literal">true</span></div><div class="line">            &#125;,</div><div class="line">            name: &#123;</div><div class="line">                $exists: <span class="literal">true</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">        $group: &#123;</div><div class="line">            _id: <span class="string">"$name"</span>,</div><div class="line">            avaAge: &#123;</div><div class="line">                $avg: <span class="string">"$age"</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">])</div></pre></td></tr></table></figure>
<p>上例中，展示出同名的几个人的平均年龄。</p>
<p><code>unwind</code> 用于拆数组，来组成新的字段。例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">把</div><div class="line"></div><div class="line">&#123;name: &quot;xiaoming&quot;, hobbies: [&quot;eating&quot;, &quot;hiking&quot;]&#125;</div><div class="line"></div><div class="line">拆为两条记录 &#123;$unwind: &quot;$hobbies&quot;&#125;</div><div class="line"></div><div class="line">&#123;name: &quot;xiaoming&quot;, hobbies: &quot;eating&quot;&#125;</div><div class="line">&#123;name: &quot;xiaoming&quot;, hobbies: &quot;hiking&quot;&#125;</div></pre></td></tr></table></figure>
<p><strong>索引</strong>：索引的作用相当于图书的目录。可以根据目录中的页码快速找到所需的内容。</p>
<p>在关系数据库中，索引是一种单独的、物理的对数据库表中一列或多列的值进行排序的一种存储结构。它是表中某一列或若干列值的集合和响应的指向表中物理标识这些值的数据页的逻辑指针清单。</p>
<p>当表中有大量记录时，若要对表进行查询，第一种搜索信息方式是全表搜索，是将所有记录一一取出，和查询条件进行一一对比，然后返回满足条件的记录，这样做会消耗大量<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/215176" target="_blank" rel="external">数据库系统</a>时间，并造成大量磁盘I/O操作；第二种就是在表中建立索引，然后在索引中找到符合查询条件的索引值，最后通过保存在索引中的ROWID（相当于页码）快速找到表中对应的记录。</p>
<p><strong>MongoDB</strong> 中创建索引<code>db.users.createIndex({name: 1})</code> 即对个条数据项的name建立升序排序的索引。</p>
<p>拿到索引： <code>db.users.getIndexes({name: 1})</code></p>
<p>给每个字段都添加索引，可以使得以后查找某个内容很方便，但每次插入一个新条目会很慢。因为插入新条目，不仅仅是插入新条目本身，也会去更新各个索引，导致插入新条目的时间变长。</p>
<p><strong>索引</strong> 本质上是一种用空间来换时间的方式。查找变快了，则空间，和每次插入修改的时间变长。</p>
<h3 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h3><p><strong>增</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// 向集合中插入一个或多个文档</div><div class="line">db.&lt;collection&gt;.insert(&#123;name: &quot;小明&quot;, age: 18&#125;)</div><div class="line">db.&lt;collection&gt;.insert([&#123;name: &quot;小明&quot;, age: 18&#125;,&#123;name: &quot;小王&quot;, age: 20&#125;])</div></pre></td></tr></table></figure>
<p>当我们向集合中插入文档时，如果没有指定文档的 <code>_id</code> 属性，那么数据库会自动为文档添加<code>_id</code>。该属性用来作文档的唯一标识。</p>
<p><code>_id</code> 可以自己指定，但必须确保它的唯一性。建议 <code>_id</code> 使用默认生成的。</p>
<blockquote>
<p><code>insertOne()</code> 插入一个文档对象</p>
<p><code>insertMany()</code> 插入多个文档对象</p>
<p><code>insertOne()</code> 和 <code>insertMany()</code> 语义上更明确</p>
</blockquote>
<p><strong>查询文档</strong></p>
<p>查询： <code>db.&lt;collection&gt;.find()</code></p>
<ul>
<li><p><code>find()</code> 用来查询文档中所有符合条件的文档。返回的是一个文档对象的集合。如：<code>db.&lt;collection&gt;.find({})[0]</code> <code>db.&lt;collection&gt;.find().length()</code> <code>db.&lt;collection&gt;.find().count()</code></p>
</li>
<li><p><code>find()</code> 可以接受一个对象作为条件参数。</p>
<blockquote>
<p>条件参数：</p>
<p>{字段名：值} 查询字段名为指定值的文档。</p>
</blockquote>
</li>
</ul>
<ul>
<li><code>db.&lt;collection&gt;.findOne()</code> 用来查询文档中符合条件的第一个文档。返回的是一个文档对象。</li>
</ul>
<p><strong>修改文档</strong></p>
<p>修改：<code>db.&lt;collection&gt;.update(查询条件，修改后新对象)</code>  <code>update</code> 默认情况下只修改符合条件的第一个。</p>
<p><code>update()</code> 默认情况下会使用新对象替换旧对象。如果是需要修改指定的属性，而不是全盘替换，需要使用<strong>修改操作符</strong>。</p>
<p>修改操作符：<code>$set</code> 可以用来修改文档中的指定属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.students.update(&#123;name:&quot;孙悟空&quot;&#125;, &#123;$set: &#123;age: 19&#125;&#125;)</div></pre></td></tr></table></figure>
<p><code>$unset</code> : 可以删除文档的指定属性，其他属性不变。</p>
<p><code>updateMany()</code> 可以同时对多个文档进行更新。</p>
<p><strong><code>update()</code> 默认的效果和 <code>updateOne()</code> 相同</strong>，如果要想有 <code>updateMany()</code> 的效果，可以给<code>update()</code> 传第三个参数：<code>{multi: true}</code></p>
<p><code>db.&lt;collection&gt;.replaceOne()</code> 专门用来做对象的替换。</p>
<p><strong>删除文档</strong></p>
<blockquote>
<p>db.collection.remove()</p>
<p>db.collection.deleteOne()</p>
<p>db.collection.deleteMany()</p>
</blockquote>
<p><code>remove</code>根据条件删除文档。默认情况下，删除符合条件的所有文档，有几个删几个。<code>remove</code> 要想只删除符合条件的第一个文档需要传第二个参数 <code>true</code></p>
<p><code>remove</code> 与  <code>find</code> 不同，<code>remove</code> 必须传参。</p>
<p><code>db.collection.remove({})</code> 会删除collection中所有的文档。用这种方法清空collection性能不高。清空了集合，但没有删除集合。</p>
<p><code>db.collection.drop()</code> 可以直接删除collection，效率更高。</p>
<p><code>db.dropDataBase()</code> 删除当前数据库。</p>
<p><strong>一般数据库中的数据都不会删除，所以删除的方法很少使用。一般会在数据中添加一个字段，来表示数据是否被删除了。</strong></p>
<p>mongodb 文档的属性值也可以是一个文档。当一个文档的属性值是一个文档时，我们称这个文档是一个内嵌文档。</p>
<p>mongodb 支持直接通过内嵌文档的形式进行查询，要查询内嵌文档，可以通过<code>.</code>的方式。</p>
<p>如果要通过内嵌文档的属性来查找文档，那么属性名必须带引号。</p>
<p><code>db.users.find({&quot;hobby.movies&quot;: &quot;hero&quot;})</code></p>
<p><code>db.users.find(name: &quot;xiaoming&quot;)</code> 是查找name为 xiaoming 的文档，或name为一个数组，数组里面包含name的文档。</p>
<p><code>db.users.update({name: &quot;xiaoming&quot;}, {$push: {&quot;hobby.movie&quot;: &quot;Intersteller&quot;} })</code></p>
<p><code>$push</code> 用于向数组中添加一个新的元素。</p>
<p><code>$addToSet</code>  用于向数组中添加一个新的元素。<code>set</code> 表示集合，如<code>charset</code>表示字符集。<code>set</code> 是不可重复的集合。所以每次<code>addToSet</code> 时，只有新的内容才能添加进去，如果数组中已经存在该元素，则添加失败。区别于<code>$push</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 向numbers集合中添加2w条数据</span></div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i&lt;=<span class="number">20000</span>; i++)&#123;</div><div class="line">	db.numbers.insert(&#123;<span class="attr">num</span>: i&#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>和上例效果相同，但性能更好的写法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = []</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;=<span class="number">20000</span>; i++)&#123;</div><div class="line">    arr.push(&#123;<span class="attr">num</span>: i&#125;)</div><div class="line">&#125;</div><div class="line">db.numbers.insert(arr)</div></pre></td></tr></table></figure>
<p>查询大于40小于50的文档：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.numbers.find(&#123;<span class="attr">num</span>: &#123;<span class="attr">$gt</span>: <span class="number">40</span>, <span class="attr">$lt</span>: <span class="number">50</span>&#125;&#125;)</div></pre></td></tr></table></figure>
<p>查询工资小于1000或大于2500的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.emp.find(&#123;$or: [&#123;sal: &#123;$lt: 1000&#125;&#125;,&#123;sal: &#123;$gt: 2500&#125;&#125;]&#125;)</div></pre></td></tr></table></figure>
<p>为所有工资低于 1000 的员工增加工资 400 元： </p>
<p><code>$inc</code> 表示自增。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.emp.updateMany(&#123;sal: &#123;$lte: 1000&#125;&#125;,&#123;$inc: &#123;sal: 400&#125;&#125;)</div></pre></td></tr></table></figure>
<p>查询numbers中的前10条数据：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.numbers.find().limit(<span class="number">10</span>)</div></pre></td></tr></table></figure>
<p>在实际开发中，我们绝对不会执行不带查询条件的查询：<code>db.numbers.find()</code> 性能会很差。</p>
<p>查看numbers中第11条到20条数据：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.numbers.find().skip(<span class="number">10</span>).limit(<span class="number">10</span>)</div></pre></td></tr></table></figure>
<p><code>skip()</code> 用于跳过指定数量的文档。</p>
<h4 id="文档之间的关系"><a href="#文档之间的关系" class="headerlink" title="文档之间的关系"></a>文档之间的关系</h4><ul>
<li><p>一对一（one to one）</p>
<blockquote>
<p>在 MongoDB 中可以通过内嵌文档的方式来体现一对一的关系。</p>
<p>db.wifeAndHusband.insert({</p>
<pre><code>name: &quot;黄蓉&quot;,

husband: {

    name: &quot;郭靖&quot;

}
</code></pre><p>})</p>
</blockquote>
</li>
<li><p>一对多（one to many）/ 多对一（many to one）</p>
<blockquote>
<p>如一个用户对应多个订单，一个订单不可能属于多个用户</p>
<p>也可以通过内嵌文档来映射一对多的关系。不过这样容易造成文档不易维护。</p>
<p>可以订单单独为一个集合，每个订单里面有一个字段表明该订单属于那个用户id</p>
</blockquote>
</li>
<li><p>多对多（many to many）</p>
<blockquote>
<p>例如： 分类和商品，一个商品可以属于多个分类，一个分类可以有多个商品。</p>
<p>老师和学生，一个老师对应多个学生，一个学生对应多个老师</p>
<p>多对多，把一对多里面的那个字段变成一个数组即可。</p>
</blockquote>
</li>
</ul>
<h4 id="sort-排序-和投影"><a href="#sort-排序-和投影" class="headerlink" title="sort(排序) 和投影"></a>sort(排序) 和投影</h4><p>查询文档时，默认是通过 <code>_id</code> 的值来升序排序。实际上就是按创建的时间来排序。</p>
<p><code>sort()</code> 函数可以用来指定排序的规则。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 按工资的升序排序：</span></div><div class="line">db.emp.find().sort(&#123;<span class="attr">sal</span>: <span class="number">1</span>&#125;)</div><div class="line"><span class="comment">// 按工资的降序排序：</span></div><div class="line">db.emp.find().sort(&#123;<span class="attr">sal</span>: <span class="number">-1</span>&#125;)</div></pre></td></tr></table></figure>
<p>在查询时，可以在查询的第二个参数位置设置查询结果的投影。即查询的结果里面一些信息我不需要显示，比如查询结果我只想看姓名和工资，我不想看_id等无关的内容。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1表示要显示，即我要显示学生的姓名。事实上_id也会默认显示</span></div><div class="line">db.students.find(&#123;&#125;,&#123;<span class="attr">name</span>: <span class="number">1</span>&#125;)</div><div class="line"><span class="comment">// 只显示学生的姓名，连默认的 _id 也不要显示了。</span></div><div class="line">db.students.find(&#123;&#125;, &#123;<span class="attr">name</span>: <span class="number">1</span>, <span class="attr">_id</span>: <span class="number">1</span>&#125;)</div></pre></td></tr></table></figure>
<h2 id="Mongoose"><a href="#Mongoose" class="headerlink" title="Mongoose"></a>Mongoose</h2><blockquote>
<ul>
<li>之前我们都是通过 shell 来完成对数据库的各种操作的，在开发中大部分时候我们都需要通过程序来完成对数据库的操作</li>
<li>而 Mongoose 就是一个让我们可以通过 Node 来操作 MongoDB 的模块</li>
<li>Mongoose 是一个对象文档模型 （ODM）库，它对 Node 原生的 MongoDB 模块进行了进一步的优化封装，并提供了更多的功能。</li>
<li>在大多数情况下，它被用来把结构化的模式应用到一个 MongoDB 集合，并提供了验证和类型转换等好处</li>
</ul>
</blockquote>
<p><code>Mongoose</code> 帮助我们把一个个数据库中的文档（表中的一行数据）映射成 JS 中的一个个的对象。操作对象就相当与我们在操作数据库。（以面向对象的形式来操作数据库）</p>
<p>mongoose 的好处</p>
<blockquote>
<ul>
<li>可以为文档创建一个模式结构（Schema，即约束），确保数据能够按一定的约束来存储，不满足约束条件则存储不成功 </li>
<li>可以对模型中的对象 / 文档进行验证</li>
<li>数据可以通过类型转换，转换为对象模型，数据存储时，数据类型不对时帮你自动的做类型转换。如年龄字段，要求存一个num，但来了一个string，则会先尝试把 string 转换成 num</li>
<li>可以使用中间件来应用业务逻辑挂钩</li>
<li>比 Node 原生的 MongoDB 驱动更加容易</li>
</ul>
</blockquote>
<p><strong>新的对象</strong></p>
<p>Mongoose 中为我们提供了几个新的对象</p>
<ul>
<li><p>Schema（模式对象）</p>
<ul>
<li>Schema 对象定义约束了数据库中的文档结构。如文档里有几个字段，分别是什么类型，哪些字段是必须的，哪些是可选的。</li>
</ul>
</li>
<li><p>Model</p>
<ul>
<li>Model 对象作为集合中的所有文档的表示，相当与 MongoDB 数据库中的集合 collection。一个 Model 对应数据库中的一个集合 collection</li>
</ul>
</li>
<li><p>Document</p>
<ul>
<li>Document 表示集合中的具体文档，相当于集合中的一个具体的文档</li>
</ul>
<p>先有 Schema 再有 Model 再有 Document</p>
</li>
</ul>
<p><strong>使用 Mongoose</strong></p>
<ol>
<li><p>安装 Mongoose </p>
<p><code>npm i --save mongoose</code></p>
</li>
<li><p>在项目中引用 mongoose</p>
<p><code>var mongoose = require(&#39;mongoose&#39;)</code></p>
</li>
<li><p>连接 MongoDB 数据库</p>
<p><code>mongoose.connect(&#39;mongodb://localhost:27017/test&#39;);</code> test 是要连接的数据库名称。默认的端口号为 27017，可以省略</p>
</li>
</ol>
<ul>
<li><p>监听 MongoDB 数据库的连接状态：</p>
<ul>
<li><p>在 mongoose 对象中，有一个属性叫 connection，该对象表示的是数据库连接，通过监听该对象的状态，可以知道数据库的连接与断开</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">mongoose.connection.once(<span class="string">'open'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'数据库已连接'</span>)</div><div class="line">&#125;)</div><div class="line">mongoose.connection.once(<span class="string">'close'</span>, fuction() &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'数据库已断开'</span>)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>数据库的断开连接： <code>mongoose.disconnect()</code> 一般不需要调用。</p>
</li>
</ul>
<ol>
<li><p>创建Schema（模式）对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>)</div><div class="line"><span class="keyword">var</span> Schema = mongoose.Schema</div><div class="line"></div><div class="line"><span class="keyword">var</span> studentSchema = <span class="keyword">new</span> Schema(&#123;</div><div class="line">    name: <span class="built_in">String</span>,</div><div class="line">    age: <span class="built_in">Number</span>,</div><div class="line">    address: <span class="built_in">String</span>,</div><div class="line">    gender: &#123;</div><div class="line">        type: <span class="built_in">String</span>,</div><div class="line">        <span class="keyword">default</span>: <span class="string">"famale"</span></div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
<li><p>通过 Schema 创建 Model</p>
<p>Model 代表数据库中的集合（表），通过Model才能对数据库中进行操作</p>
<p><code>mongoose.model(modelName, schema)</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> StudentModel = mongoose.model(<span class="string">'student'</span>, studentSchema)</div><div class="line"></div><div class="line"><span class="comment">// 向 student 集合中插入文档：</span></div><div class="line"><span class="comment">// StudentModel.create(要插入的文档，回调函数)</span></div><div class="line"></div><div class="line">StudentModel.create(&#123;</div><div class="line">    name: <span class="string">"小明"</span>,</div><div class="line">    age: <span class="number">18</span>,</div><div class="line">    gender:<span class="string">"male"</span>,</div><div class="line">    address: <span class="string">"雷峰塔"</span></div><div class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span>(!err) &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'插入成功~~~'</span>)</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p><strong>mongoose会自动将集合名变成复数形式</strong></p>
</li>
</ol>
<p>有了 Model 我们就可以对数据库进行增删改查的操作了。</p>
<p>Model 是一个构造函数，有些 API 是由 Model 来调用的，有些 API 是由 Model 的实例来调用的。</p>
<p><strong>增</strong>： </p>
<blockquote>
<p> Model.create(doc(s), [callback]): 用来创建一个文档或多个并添加到数据库中。</p>
<p> 参数： </p>
<pre><code>doc(s):可以是一个文档对象，也可以是一个文档对象的数组。

callback： 可选参数，当操作完成后调用的回调函数
</code></pre></blockquote>
<p><strong>查</strong>: </p>
<blockquote>
<ul>
<li>查询所有符合条件的文档</li>
</ul>
<p>Model.find(conditions, [projection], [options], [callback])</p>
<p>总会返回一个数组</p>
<ul>
<li>根据文档的 id 属性查询文档</li>
</ul>
<p>Model.findById(id, [projection], [options], [callback])</p>
<ul>
<li>查询符合条件的第一个文档</li>
</ul>
<p>总会返回一个具体的文档对象。</p>
<p>Model.findOne([conditions], [projection], [options], [callback])</p>
<p>conditions 查询的条件</p>
<p>projection 投影</p>
<p>options 查询的选项（skip ，limit等）</p>
<p>callback 回调函数，查询结果会通过回调函数返回。回调函数必传，不然拿不到结果。</p>
<p>通过 find() 查询的结果，返回的对象，就是Document， 文档对象</p>
<p>Document 对象是 Model 的实例</p>
</blockquote>
<p><strong>改</strong>: </p>
<blockquote>
<p>Model.update(conditions, doc, [options], [callback])</p>
<p>Model.updateOne(conditions, doc, [options], [callback])</p>
<p>Model.updateMany(conditions, doc, [options], [callback])</p>
<p>Model.replaceOne(conditions, doc, [options], [callback])</p>
<p>update() 用来下修改一个或多个文档</p>
<p>参数：</p>
<pre><code>conditions： 查询条件

document： 修改后的对象

options： 配置参数

callback： 回调函数
</code></pre></blockquote>
<p><strong>删</strong>：</p>
<blockquote>
<p> Model.remove(conditions, [callback])</p>
<p> Model.deleteOne(conditions, [callback])</p>
<p> Model.deleteMany(conditions, [callback])</p>
</blockquote>
<p> Model.count(conditions, [callback]): 统计文档的数量。</p>
<h4 id="Document-的方法"><a href="#Document-的方法" class="headerlink" title="Document 的方法"></a>Document 的方法</h4><p>Document 就是我们通过 mongoose 查询到的数据，和集合中的文档一一对应。Document 是 Model 的实例，通过 Model 查询到的结果都是 Document.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建一个 Document</span></div><div class="line"><span class="keyword">var</span> stu = <span class="keyword">new</span> StuModel(&#123;</div><div class="line">    name: <span class="string">"奔波霸"</span>,</div><div class="line">    age: <span class="number">48</span>,</div><div class="line">    gender: <span class="string">"male"</span>,</div><div class="line">    address: <span class="string">"碧波潭"</span></div><div class="line">&#125;) </div><div class="line"><span class="comment">// 这样生成的 Document 并没有插入到数据库。</span></div></pre></td></tr></table></figure>
<p><strong>Document 的方法</strong></p>
<blockquote>
<ul>
<li><p>save()</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;   stu.save(fuction(err) &#123;</div><div class="line">&gt;       <span class="keyword">if</span>(!err) &#123;</div><div class="line">&gt;       	<span class="built_in">console</span>.log(<span class="string">"保存成功"</span>)</div><div class="line">&gt;       &#125;</div><div class="line">&gt;   &#125;)</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<p>&gt;</p>
<blockquote>
<ul>
<li>update(update, [options], [callback]) 修改对象</li>
<li>remove([callback]) 删除对象</li>
<li>toObject() 将Document对象转换为普通 JS 对象。转换为普通JS对象以后，注意所有的 Document对象的方法或属性都不能使用了。一般要删除document对象的时候需要使用 toObject() 方法。</li>
</ul>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> match = &#123;&#125;</div><div class="line">    <span class="keyword">const</span> flow = UserModel.find(match)</div><div class="line">    <span class="keyword">const</span> users = <span class="keyword">await</span> flow.exec()</div><div class="line">    <span class="keyword">return</span> users</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Node-js-中的异步"><a href="#Node-js-中的异步" class="headerlink" title="Node.js 中的异步"></a>Node.js 中的异步</h2><p>Node.js 约定，回调函数中第一个参数为错误，第二个参数（及以后）为返回的结果</p>
<p>Promise +  async/await 是现在主流的异步处理方案。</p>
<p><code>async</code> 的返回结果是一个 <code>Promise</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">'done'</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">const</span> p = foo() <span class="comment">// p 会是一个Promise 对象</span></div><div class="line"><span class="built_in">console</span>.log(p)</div><div class="line">p.then(<span class="function">(<span class="params">r</span>) =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(r)</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// 打印结果：</span></div><div class="line"><span class="comment">// Promise &#123; ‘done’ &#125;</span></div><div class="line"><span class="comment">// done</span></div></pre></td></tr></table></figure>
<p><code>await</code> 作用域一定是在一个<code>async</code>函数内部。<code>await</code> 作用于一个 <code>Promise</code> 。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> r = <span class="keyword">await</span> bar()</div><div class="line">    <span class="built_in">console</span>.log(r)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">'bar'</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">foo()	<span class="comment">// 打印出 bar</span></div><div class="line">foo().then() <span class="comment">// 打印出 bar</span></div></pre></td></tr></table></figure>
<p><code>await</code> 用于直接拿到 <code>Promise</code> 中的返回值。同理，promise实例.then( (r) =&gt; {</p>
<p>console.log(r) } ) 这里的<code>then</code> 也可以拿到 <code>Promise</code> 中的返回值。</p>
<p><code>await</code> 等待 <code>Promise</code> 执行完成以后，拿到 <code>Promise</code> 返回的结果，赋值给变量。</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> r = <span class="keyword">await</span> bar()</div><div class="line">    <span class="built_in">console</span>.log(r)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">        resolve(<span class="string">'bar'</span>)</div><div class="line">    &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">foo().then()	<span class="comment">// 也是打印出 bar</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> r = <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</div><div class="line">        resolve(<span class="string">'bar'</span>)</div><div class="line">    &#125;)</div><div class="line">&#125;</div><div class="line">foo().then()	<span class="comment">// 也是打印出 bar</span></div></pre></td></tr></table></figure>
<p><strong>如何把平时回调函数风格的异步代码，改造成Promise风格的？</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 改造前：</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">params, callback</span>) </span>&#123;</div><div class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">        callback(<span class="literal">null</span>,<span class="string">'done'</span>)</div><div class="line">    &#125;,<span class="number">2000</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 改造后：</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncFoo</span>(<span class="params">params</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">        foo(params, (err, result) =&gt; &#123;</div><div class="line">            <span class="keyword">if</span>(err) reject(err)</div><div class="line">            <span class="keyword">else</span> resolve(result)</div><div class="line">        &#125;)</div><div class="line">    &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">(<span class="keyword">async</span> () =&gt; &#123;</div><div class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> asyncFoo(&#123;&#125;)</div><div class="line">    <span class="built_in">console</span>.log(result)</div><div class="line">&#125;)()</div><div class="line">    .then(<span class="function"><span class="params">r</span> =&gt;</span> &#123;</div><div class="line">	&#125;)</div><div class="line">    .catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</div><div class="line">	&#125;)</div><div class="line"><span class="comment">// 打印出 'done'</span></div></pre></td></tr></table></figure>
<p> <strong>在异步的情况下，设想这样一种情形：两个同时进行的异步操作，我要最后等两个异步都结束后，总和两个异步返回的结果来做下一步的操作</strong></p>
<p>由于这两个异步都是同级的，不存在一个异步成功之后再去调用另一个异步，所以在传统的回调方式的异步书写中，很难解决这个问题。</p>
<p>解决上面这个问题，传统的冗余的两种写法：</p>
<blockquote>
<ul>
<li>第一种，把其中的一个异步操作放在另一个异步操作成功之后的回调中。这种方案浪费了时间</li>
<li>第二种，两个异步操作同时进行，有两个全局变量来分别保存异步操作结果，异步操作结果有默认值，异步操作成功之后，修改对应的全局变量。两个异步操作同时进行，任何一个异步操作结束后都通过全局变量是否已经被修改了知道下是否要进入下一步。</li>
</ul>
</blockquote>
<p>这面的这种情况就是回调地狱。</p>
<p><code>Promise.all([])</code> 有助于解决两个异步同时进行，但要等到两个异步的结果都返回了才进行下一步操作。</p>
<p> <code>Promise.all()</code> 接受一个数组参数，数组中的元素应该是一个个的 <code>Promise</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">    </div><div class="line">&#125;)</div><div class="line"><span class="keyword">const</span> p1 = <span class="built_in">Promise</span>.resolve(<span class="literal">true</span>)</div><div class="line"><span class="keyword">const</span> p2 = <span class="built_in">Promise</span>.reject(<span class="literal">false</span>)</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(p)	<span class="comment">//打印出： Promise &#123; &lt;pending&gt; &#125;</span></div><div class="line"><span class="built_in">console</span>.log(p1) <span class="comment">//打印出： Promise &#123; true &#125;</span></div><div class="line"><span class="built_in">console</span>.log(p2) <span class="comment">//打印出： Promise &#123; &lt;rejected&gt; false &#125;</span></div></pre></td></tr></table></figure>
<p>初始的 Promise 处于 pending(等待) 状态。当在传入Promise中的函数中执行<code>resolve</code> 或 <code>reject</code> 时，会把 Promise 的状态永久的改为<code>fulfilled(已完成)</code>或 <code>rejected(已拒绝)</code>。这个状态是不可逆的。</p>
<p>一旦状态由 <code>pending</code> 变为 <code>fulfilled</code> 或 <code>rejected</code> 时，即状态已经定下来了。<code>then</code> 语句就可以异步的取到<code>resovle</code> 或 <code>rejected</code> 的结果。 </p>
<p>Promise 的 then 语句支持链式调用，只要前一个then语句返回的是一个 Promise 对象，后面的 then 就能正常的执行。</p>
<p> Promise 的链式调用 then 语句中，只要第一次出现了reject，后面的then语句都不会调用了，直接转入<code>catch</code> 语句。</p>
<p><code>then</code> 函数接受两个参数，第一个参数为成功回调，第二个参数为错误回调。第二个参数一般不使用，错误我们统一使用 <code>catch</code> 来处理。</p>
<p><code>then</code> 第二个参数的使用，导致最后的 <code>catch</code> 不能成功的捕捉到错误。相当于错误被拦截了。</p>
<blockquote>
<ul>
<li><p>new Promise() 传入的函数是同步执行的。</p>
</li>
<li><p>then() 方法是异步执行的。then() 的执行必须等待Promise的状态有pending变为其他。</p>
</li>
<li>Promise 的状态一旦变化，就不可逆了。</li>
<li>then() 方法接受两个回调函数，一个是成功的回调，另一个是出错的回调。出错的回调拦截了对错误的处理会导致最后的catch不能捕捉错误。</li>
</ul>
</blockquote>
<p><strong>异步的终极解决方案： async/await + Promise</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 被 async 修饰的函数最终返回的都是一个Promise对象</span></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">foo()</div><div class="line">    .then( <span class="function"><span class="params">r</span> =&gt;</span> &#123;</div><div class="line">    	<span class="built_in">console</span>.log(r)	<span class="comment">// 打印出 true</span></div><div class="line">	&#125; )</div></pre></td></tr></table></figure>
<p><strong>await</strong> 关键字，只能在 <strong>async</strong> 修饰的函数中使用。<strong>await</strong> 关键字作用于一个Promise。用于拿到Promise异步结束后返回的结果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="literal">true</span>)</div><div class="line">    </div><div class="line">    <span class="built_in">console</span>.log(result)</div><div class="line">&#125;</div><div class="line">foo().then(<span class="function"><span class="params">r</span> =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(r)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p><strong>await</strong> 的作用： <strong>await</strong> 作用于一个Promise，把本来传统方式用then才能拿到的Promise返回值赋值给左边的变量。</p>
<p> 可以把 <strong>await</strong> 想象为同步代码，<strong>await</strong> 后面的Promise状态确定下来之前，<strong>await</strong> 后面的代码是不会执行的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</div><div class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="number">2</span>)</div><div class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="number">3</span>)</div><div class="line">            resolve(<span class="literal">true</span>)</div><div class="line">            <span class="built_in">console</span>.log(<span class="number">4</span>)</div><div class="line">        &#125;,<span class="number">1000</span>)</div><div class="line">    &#125;)</div><div class="line">    <span class="built_in">console</span>.log(<span class="number">5</span>)</div><div class="line">    <span class="built_in">console</span>.log(result)</div><div class="line">&#125;</div><div class="line">foo()</div><div class="line"><span class="comment">// 打印的结果为：</span></div><div class="line"><span class="comment">// 1</span></div><div class="line"><span class="comment">// 2</span></div><div class="line"><span class="comment">// 3</span></div><div class="line"><span class="comment">// 4</span></div><div class="line"><span class="comment">// 5</span></div><div class="line"><span class="comment">// true</span></div></pre></td></tr></table></figure>
<p><strong>Promise.all可以将多个Promise实例包装成一个新的Promise实例。同时，成功和失败的返回值是不同的，成功的时候返回的是一个结果数组，而失败的时候则返回最先被reject失败状态的值。</strong></p>
<p><strong>Promse.race就是赛跑的意思，意思就是说，Promise.race([p1, p2, p3])里面哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态。</strong></p>
<h2 id="错误处理和日志"><a href="#错误处理和日志" class="headerlink" title="错误处理和日志"></a>错误处理和日志</h2><p>JavaScript 引擎是单线程的，因此一旦遇到异常，JavaScript 引擎通常会停止执行，阻塞后续代码并抛出一个异常信息。因此对于一个可预见的异常，我们应该捕捉并正确展示给用户或开发者。</p>
<p><strong>一个 Error 对象类型的异常不仅包含一个异常信息，同时也包含一个追溯栈</strong> 这样你就很容易通过追溯栈来代码出错的行数了。</p>
<p><strong>throw</strong> 语句用来抛出一个用户自定义的异常。当前函数的执行将被停止（throw 只会的语句不会执行）并且控制将被传递到调用堆栈中的第一个 catch 块。如果调用者没有catch块，程序将会终止。</p>
<p><strong>window.onerror</strong></p>
<p>通过在 <strong>window.onerror</strong> 上定义一个事件监听函数，程序中其他代码产生的未被捕捉的异常往往就会被 <strong>window.onerror</strong> 上面注册的监听函数捕获到，并且同时捕获到一些关于异常的信息。</p>
<p>无论是 <strong>try/catch</strong> 还是 <strong>promise</strong> 都能捕获到 “ 同步 ” 异常</p>
<p><strong>promise.reject()</strong>  是回调，而 <strong>throw</strong> 只是一个同步的语句，如果在另一个异步的上下文中抛出，在当前上下文是无法捕捉到的。</p>
<p>因此在 <strong>promise</strong> 中使用 <strong>reject</strong> 抛出异常。否则 <strong>catch</strong> 有可能会捕捉不到。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Promise</span>.resolve()</div><div class="line">    .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'throw error'</span>)</div><div class="line">        &#125;,<span class="number">0</span>)</div><div class="line">	&#125;)</div><div class="line">    .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</div><div class="line">    	<span class="built_in">console</span>.log(err)</div><div class="line">	&#125;)</div><div class="line"><span class="comment">// Uncaught Error: throw error</span></div></pre></td></tr></table></figure>
<p>而这样写就可以捕捉：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Promise</span>.resolve()</div><div class="line">.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">            reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'throw error'</span>))</div><div class="line">        &#125;, <span class="number">0</span>)</div><div class="line">    &#125;)    </div><div class="line">&#125;)</div><div class="line">.catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</div><div class="line">    consol.log(err)</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">//Error: throw error</span></div></pre></td></tr></table></figure>
<p>在生产环境中的错误处理和调试比较麻烦：</p>
<p>首先，对服务高稳定性的需求导致我们不能把服务器中的代码打上断点慢慢调试，这样服务器会相应的被阻塞。</p>
<p>其次，在不确定错误产生的地点时，一点点增加 console.log 的深度然后不断重启服务显然不现实</p>
<p>再者，使用我们服务的用户应该尽快地知道有错误发生，并且受到相应的解决方案。</p>
<p>这对服务器的错误处理和记录提出了一些要求：</p>
<ol>
<li>错误必须在合适的地方被抛出，便于我们快速定位是哪一行代码出了问题</li>
<li><strong>产生错误时，必须要做一些及时的处理，保证服务器能够对这次请求产生合适的响应</strong>。</li>
</ol>
<p>错误处理要实现：</p>
<ul>
<li>要能知道是哪一行代码出的错</li>
<li>要能知道是出错代码执行时的上下文环境</li>
<li>正确的记录错误</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 不仅可以抛出错误的提示信息，还可以给出程序的调用栈</span></div><div class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'something went wrong'</span>)</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> obj = &#123;</div><div class="line">    message: <span class="string">"something went wrong"</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">Error</span>.captureStackTrace(obj);</div><div class="line"><span class="keyword">throw</span> obj</div></pre></td></tr></table></figure>
<p>捕获一个错误：</p>
<ul>
<li>捕获同步错误</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 在同步代码中捕获一个错误</span></div><div class="line"><span class="comment">// 即错误出现了，不是直接抛出完事，而是通过try/catch这种方式处理一下。</span></div><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'oh no'</span>)</div><div class="line">&#125;<span class="keyword">catch</span>(e) &#123;</div><div class="line">    <span class="built_in">console</span>.log(e)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>捕获异步错误</li>
</ul>
<p>以前的处理异步错误的方式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">params, callback</span>) </span>&#123;</div><div class="line">    <span class="comment">// 一些异步操作出现了错误，如数据库读取之类的。出现错误不能直接 throw new Error(),会导致调用这些异步操作的那个函数直接挂掉，连错误信息都拿不到。要想出现了错误程序依然能正常不崩溃，就要把错误信息传给callback函数，在 callback 函数里面对错误进行处理</span></div><div class="line">    <span class="keyword">const</span> error = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'something wrong async'</span>)</div><div class="line">    <span class="keyword">if</span>(error) callback(error)</div><div class="line">&#125;</div><div class="line"></div><div class="line">foo(&#123;&#125;, (err) =&gt; &#123;</div><div class="line">    <span class="keyword">if</span>(err) &#123;</div><div class="line">        <span class="built_in">console</span>.log(err)</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>使用更清晰的 <code>async/await</code> 来写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 用 Promise 的catch来捕获错误</span></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'something wrong async'</span>)</div><div class="line">    &#125;,<span class="number">1000</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line">(<span class="keyword">async</span> () =&gt; &#123;</div><div class="line">    <span class="keyword">await</span> foo()</div><div class="line">&#125;)().then(<span class="function"><span class="params">r</span> =&gt;</span> &#123; </div><div class="line">&#125;).catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(e)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>或者：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 用 try / catch 来捕获错误</span></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">try</span>&#123;</div><div class="line">        <span class="keyword">await</span> bar()</div><div class="line">    &#125;<span class="keyword">catch</span>(e)&#123;</div><div class="line">        <span class="built_in">console</span>.log(e)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'async function got wrong'</span>)</div><div class="line">&#125;</div><div class="line">foo()</div></pre></td></tr></table></figure></p>
<p>但是如果试图在 async 函数外用 try / catch:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error in bar'</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">    (<span class="keyword">async</span> ()=&gt; &#123;</div><div class="line">        <span class="keyword">await</span> bar()</div><div class="line">    &#125;)()</div><div class="line">&#125;<span class="keyword">catch</span>(e) &#123;</div><div class="line">    <span class="built_in">console</span>.log(e)</div><div class="line">&#125;</div><div class="line"><span class="comment">// await里面抛出了一个错误，这个错误还被async包装成了一个promise</span></div><div class="line"><span class="comment">// 外层试图捕获这个并非错误而是promise的东西，注定是是失败的。</span></div><div class="line"><span class="comment">// 最终执行的结果是：你会收获一份 unhandledRejection</span></div></pre></td></tr></table></figure>
<hr>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">await</span> bar()</div><div class="line">        .catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</div><div class="line">        	<span class="built_in">console</span>.log(<span class="string">'bar caught err'</span>)</div><div class="line">        	<span class="keyword">throw</span> e</div><div class="line">    	&#125;)</div><div class="line">&#125;</div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'async function bar got wrong'</span>)</div><div class="line">&#125;</div><div class="line">foo()</div><div class="line">    .catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</div><div class="line">    	<span class="built_in">console</span>.log(<span class="string">'foo caught err'</span>)</div><div class="line">	&#125;)</div><div class="line"></div><div class="line"><span class="comment">// 两个console.log都会执行</span></div><div class="line"><span class="comment">// 如果没有 throw e,则只会打印出 'bar caught err'</span></div><div class="line"><span class="comment">// 前面的catch把错误处理掉了之后，后面的catch就捕捉不到这条错误</span></div></pre></td></tr></table></figure>
<p><strong>关于 unhandledRejection 和 uncaughtException</strong></p>
<ul>
<li><p>如果在 Promise 中抛出了一个异常，却没有被<code>.catch</code> 拦截，就会出现 <code>unhandleRejecition</code></p>
</li>
<li><p>如果出现了一个 <code>exception</code>, 却没有被 try/catch 包裹住，则会出现 <code>uncaughtException</code></p>
</li>
</ul>
<p>在如 Java 一些语言中，错误和异常有所区别，它们分属不同的类别。</p>
<p>通常错误是非正常的系统级的严重错误，出现后程序直接终止，这种错误是不应该的、或是不可预见的，不推荐用 <code>try/catch</code> 来捕获处理。</p>
<p>异常是程序运行时不满足某些条件而出现的非严重的错误，应音量使用<code>try-catch</code>来捕获它。</p>
<p>而在 JS 中，只定义了错误（Error），作为其内置的对象，其原型对象一般包括 name 和 message 两个属性。不同浏览器还实现了不同的错误类型以及附加的属性和方法。</p>
<p>异常（Exception） 只是错误的另一种说法，它们实际上是一个东西。都可以用 <code>try-catch</code> 来处理，因此不用在意它们的处理方式。一个异常对象，在 JS 里实际上就是一个拥有 name 和 message 属性的Error实例罢了。</p>
<p>唯一不同的是：JS 中异常可以以字符串、数字、布尔值或对象的形式来了抛出处理，而错误通常特指Error对象及其继承的自定义子对象。</p>
<p><strong>HTTP 请求的异常处理和自定义错误码</strong></p>
<p>如果在一次 HTTP 请求中，有错误被产生，应该立即返回这次请求，并附上相应的错误码和提示信息。</p>
<p>我们使用拓展过的 Error 类来实现这个效果：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">HTTPBaseError</span> <span class="keyword">extends</span> <span class="title">Error</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(httpStatusCode, httpMsg, errCode, msg) &#123;</div><div class="line">        <span class="keyword">super</span>(<span class="string">`HTTP ERROR: <span class="subst">$&#123;msg&#125;</span>`</span>)</div><div class="line">        <span class="keyword">this</span>.httpStatusCode = httpStatusCode;</div><div class="line">        <span class="keyword">this</span>.httpMsg = httpMsg</div><div class="line">        <span class="keyword">this</span>.errCode = errCode</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> HTTPBaseError(<span class="number">404</span>, <span class="string">'资源不存在'</span>, <span class="number">100000</span>, <span class="string">'resource not found'</span>)</div><div class="line">&#125;<span class="keyword">catch</span> (e) &#123;</div><div class="line">    <span class="built_in">console</span>.log(e.message)</div><div class="line">    <span class="built_in">console</span>.log(e.httpStatusCode)</div><div class="line">    <span class="built_in">console</span>.log(e.httpMsg)</div><div class="line">    <span class="built_in">console</span>.log(e.errCode)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>httpStatusCode</code> 是http 的code，需要传个前端的。而 <code>errCode</code> 用于后代维护的错误代码。如http找不到资源为<code>404</code> ，<code>errCode</code> 就可以在<code>404</code>的基础上来拓展。如：<code>40401</code> 为文章找不到，<code>40402</code> 为图片找不到。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">router.get(<span class="string">'/'</span>, (req, res,next) =&gt; &#123;</div><div class="line">    (<span class="keyword">async</span> () =&gt; &#123;</div><div class="line">        <span class="keyword">const</span> users = <span class="keyword">await</span> UserService.getAllUsers()</div><div class="line">        res.locals.users = users</div><div class="line">    &#125;)()</div><div class="line">        .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">        	res.render(<span class="string">'users'</span>)</div><div class="line">    	&#125;)</div><div class="line">        .catch(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</div><div class="line">        	next(e)</div><div class="line">   		&#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// error handler</span></div><div class="line">app.use(<span class="function">(<span class="params">err, req, res, next</span>) =&gt;</span> &#123;</div><div class="line">   	<span class="comment">// set locals, only providing error in development</span></div><div class="line">    res.locals.message = err.message;</div><div class="line">    res.locals.error = req.app.get(<span class="string">'env'</span>) === <span class="string">'development'</span> ? err: &#123;&#125;</div><div class="line">    </div><div class="line">    <span class="comment">// render the error page</span></div><div class="line">    res.status(err.status || <span class="number">500</span>)</div><div class="line">    res.render(<span class="string">'error'</span>)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ./middleware/http_error_handler.js</span></div><div class="line"><span class="keyword">const</span> HTTPBaseError = <span class="built_in">require</span>(<span class="string">'../errors//http_base_error'</span>)</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">handler</span>(<span class="params">options</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">err, req, res, next</span>)</span>&#123;</div><div class="line">        <span class="keyword">if</span>(err <span class="keyword">instanceof</span> HTTPBaseError) &#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;err.httpStatusCode&#125;</span> <span class="subst">$&#123;err.msg&#125;</span> <span class="subst">$&#123;err.errorCode&#125;</span>`</span>, err)</div><div class="line">            res.statusCode = err.httpStatusCode</div><div class="line">            res.json(&#123;</div><div class="line">                code: err.errCode,</div><div class="line">                msg: err.httpMsg,</div><div class="line">            &#125;)</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            next(err)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="built_in">module</span>.exports = handler</div></pre></td></tr></table></figure>
<h4 id="日志文件"><a href="#日志文件" class="headerlink" title="日志文件"></a>日志文件</h4><p>对于没有捕捉的错误和promise：</p>
<blockquote>
<p>// 对于没有捕捉的错误，程序会崩掉，在崩掉之前，我们需要记录日志</p>
<p>process.on(‘unhandledRejection’, (reason, p) =&gt; {</p>
<pre><code>console.log(reason)

console.log(p)

process.exit(1)
</code></pre><p>})</p>
<p>process.on(‘uncaughtException’, (err) =&gt; {</p>
<p>})</p>
</blockquote>
<p>前面我们已经提到，应该在正确的位置将错误对应的内容打印出来。然而在 Node.js 中，如果我们直接使用 console.log 来打印错误，是不太好的。</p>
<p>首先，如果不重定向 console.log 到文件，那么日志并没有被持久化，这肯定是不行滴</p>
<p>其次，Node.js 的 console.log 的输出，会根据输出的目的对象，有可能进行同步输出，会阻塞进程。</p>
<p>写日志到一个硬盘文件一定是一个异步的过程。需要考虑日志在真正开始写入的时候是否发生了变化。</p>
<p>我们将会使用 <code>winston</code> 来进行日志处理。</p>
<p><strong>winston</strong> 是一个异步 Node.js 日志库，有多文件多等级输出的功能。</p>
<p>日志不仅是你要打印的信息，还包括：</p>
<ul>
<li>是哪一行代码打印出来的。</li>
<li>日志分级： <code>info</code> 、<code>debug</code> 、<code>verbose</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> winston = <span class="built_in">require</span>(<span class="string">'winston'</span>)</div><div class="line"><span class="keyword">const</span> &#123; Logger, transports &#125; = winston</div><div class="line"><span class="keyword">const</span> logger = <span class="keyword">new</span> Logger(&#123;</div><div class="line">    transports: [</div><div class="line">        <span class="keyword">new</span> transports.File(&#123;</div><div class="line">            name: <span class="string">'error_logger'</span>,</div><div class="line">            filename: <span class="string">'logs/error.log'</span>,</div><div class="line">            level: <span class="string">'error'</span></div><div class="line">        &#125;) ,</div><div class="line">        <span class="keyword">new</span> transports.Console(&#123;</div><div class="line">            level: <span class="string">'error'</span></div><div class="line">            <span class="comment">// 只有 error 才被同时console</span></div><div class="line">        &#125;),</div><div class="line">        <span class="keyword">new</span> transports.File(&#123;</div><div class="line">            name: <span class="string">'info_logger'</span>,</div><div class="line">            filename: <span class="string">'logs/info.log'</span>,</div><div class="line">            level: <span class="string">'info'</span></div><div class="line">        &#125;)</div><div class="line">    ]</div><div class="line">&#125;);</div><div class="line"></div><div class="line">logger.info(<span class="string">'my first log with winston'</span>) <span class="comment">// 这一条会进入 info.log 文件</span></div><div class="line">logger.error(<span class="string">'my first error log with winston'</span>) <span class="comment">// 这一条既会进入 error.log 文件，也会进入 info.log 文件。因为 error 的 level 级别比 info 高</span></div><div class="line"><span class="comment">// 要加额外的信息，只需传入到 logger.info()的第二个参数里。logger.error 也是同理</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> err = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'oops'</span>)</div><div class="line">logger.info(<span class="string">'this is a error: '</span>, &#123;<span class="attr">err</span>: err.stack&#125;)</div></pre></td></tr></table></figure>
<p>接下来讲一下配置：</p>
<p><strong>Transport</strong></p>
<p>Winston 可以对日志根据等级（比如 verbose、debug、error）将日志分类并输出到不同的文件中。</p>
<p><strong>transport</strong> 即日志输出到哪里去。</p>
<p><strong>日志滚动（log rotation）</strong></p>
<p>每天生成的日志，都要放到不同的文件中。以当天的日期作为文件名。</p>
<p>随着服务的运行，日志会越来越大，如果不做管理，迟早会导致服务器磁盘被塞满。</p>
<p>我们使用 npm 上的 <code>winston-daily-rotate-file</code> 进行日志滚动。<code>winston-daily-rotate-file</code>  是 <code>winston</code> 之外的第三方模块。</p>
<p><code>winston-daily-rotate-file</code> 用于拓展 <code>winston</code> 自带的 <code>transport</code> 。只需要在 <code>winston</code> 之后引用即可。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> winston = <span class="built_in">require</span>(<span class="string">'winston'</span>)</div><div class="line"><span class="built_in">require</span>(<span class="string">'winston-daily-rotate-file'</span>)</div><div class="line"></div><div class="line"><span class="keyword">const</span> &#123; Logger, transports &#125; = winston;</div><div class="line"></div><div class="line"><span class="keyword">const</span> logger = <span class="keyword">new</span> Logger(&#123;</div><div class="line">    transports: [</div><div class="line">        <span class="keyword">new</span> transports.Console(),</div><div class="line">        <span class="keyword">new</span> transports.DailyRotateFile(&#123;</div><div class="line">            filename: <span class="string">'./logs/.info.log'</span>,</div><div class="line">            datePattern: <span class="string">'yyyy_MM_dd'</span>, <span class="comment">// 日期格式</span></div><div class="line">            prepend: <span class="literal">true</span>, <span class="comment">// 即日期添加到文件名前面</span></div><div class="line">            level: <span class="string">'info'</span></div><div class="line">        &#125;)</div><div class="line">    ]</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h2 id="鉴权（用户登录与注册）"><a href="#鉴权（用户登录与注册）" class="headerlink" title="鉴权（用户登录与注册）"></a>鉴权（用户登录与注册）</h2><ul>
<li>用户名密码登录 <code>session</code> 机制</li>
<li>微信扫码登录（Oauth2协议）</li>
<li>JWT 机制</li>
</ul>
<p><strong>Session</strong></p>
<p><strong>Session</strong> 一般译作 <code>会话</code> 。在 <code>web</code> 应用的用户看来，<strong>session</strong> 是一种记录客户状态的机制，不同的是cookie保存在客户端浏览器中，而 <strong>session</strong> 报错在服务器上。</p>
<p>客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。客户端再次访问时只需要从该 Session 中查找该客户的状态就可以了。</p>
<p>在用户登录后，服务器存储用户会话的相关信息，并为客户端指定一个访问凭证，如果有客户端凭此凭证发出请求，则在服务器存储的信息中取出用户相关登录信息并使用。</p>
<blockquote>
<ol>
<li>服务器生成全局唯一标识符（sessionId）</li>
<li>开辟数据存储空间，一般对在内存中创建对应的数据结构。</li>
<li>将 session 的全局唯一标识符发送给客户端</li>
</ol>
</blockquote>
<p>问题的关键就在于 <strong>服务器端如何发送这个 session 的唯一标识</strong>。联系到HTTP协议，数据无非可以放在请求行、头域或Body里，基于此，一般来说会有两种常用的方式： <code>cookie</code> 和 <code>URL重写</code></p>
<p>服务器返回的凭证常存储于 Cookie 中。</p>
<p>基于 Session 和其他服务器存储凭证的鉴权机制有一个问题，对分布式系统比较不友好。如果用户的请求会到达两台服务器上，那么如果其中一台没有登录过，鉴权就会失败。</p>
<p>解决这种问题有数种方法：</p>
<ol>
<li>存储的数据库是分布式的，访问任意一台机器时，实际上都会从分布式数据库（数据中心）调取凭证</li>
<li>通过流量分发，保证同一 SessionId 的用户，每次请求都会到同一台服务器（数据库）上</li>
</ol>
<p><strong>JWT（jsonwebtoken）</strong></p>
<p><code>JWT</code> 是一种无状态的鉴权机制。将用户登录后的一些信息（比如用户的 Id）和过期时间等信息存储在一个加密过的字符串中，当服务器接受到请求的时候，进行解密并直接使用信息。</p>
<p><code>JWT</code>的组成： 使用 base64 编码描述 jwt 头部、使用base64编码的 payload，以及加密签名</p>
<p>我们将使用 <code>jsonwebtoken</code> 模块管理 JWT</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> JWT = <span class="built_in">require</span>(<span class="string">'jsonwebtoken'</span>)</div><div class="line">router.get(<span class="string">'/login'</span>, (req, res, next) =&gt; &#123;</div><div class="line">    <span class="keyword">const</span> &#123; username &#125; req.query;</div><div class="line">    <span class="keyword">const</span> user = &#123;username&#125;</div><div class="line">    <span class="keyword">const</span> token = JWT.sign(user,<span class="string">'zhelishimiyue'</span>)</div><div class="line">    res.send(token)	<span class="comment">// 返回一个长长的字符串</span></div><div class="line">&#125;)</div><div class="line">router.get(<span class="string">'/hello'</span>, (req, res, next) =&gt; &#123;</div><div class="line">    <span class="keyword">const</span> auth = req,get(<span class="string">'Authorization'</span>)</div><div class="line">    <span class="keyword">if</span>(!auth) <span class="keyword">return</span> res.send(<span class="string">'no auth'</span>)</div><div class="line">    <span class="keyword">if</span>(auth.indexOf(<span class="string">'Bearer '</span>) === <span class="number">-1</span>)<span class="keyword">return</span> res.send(<span class="string">'no auth'</span>)</div><div class="line">    cont token = auth.split(<span class="string">'Bearer '</span>)[<span class="number">1</span>]</div><div class="line">    <span class="keyword">const</span> user = JWT.verify(token, <span class="string">'zhelishimiyue'</span>)</div><div class="line">    res.send(user);</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 客户端在拿到后台返回的token之后，需要前端在以后发送的http请求头中添加一个字段。</span></div><div class="line"><span class="comment">// Authorization:Bearer 一个空格后接之前返回的token 通过发AJAX请求时，XMLHttpRequest。setRequestHeader() 来设置。</span></div></pre></td></tr></table></figure>
<p><strong>Cookie-Session</strong></p>
<p>Express 的一个中间件，与 JWT 类似，使用签名+明文的方法在cookie中存储session，使用 sha256 算法进行加密。<strong>cookie-session</strong> 是直接把信息写到了cookie中。加密了。故服务器重启不会丢失。<strong>cookie-session</strong> 是用base64加密后放在cookie中，这个cookie当然是可以伪造的，但这个 <strong>cookie</strong> 要有个签名，两者是一一对应的。签名是根据cookie内容和后台的密钥（key）计算得到的。cookie内容可伪造，但签名不能伪造出来。</p>
<p><strong>express-session</strong></p>
<p>express-session 中间件会将会话数据存储在服务器上；它仅将会话标识（而非会话数据）保存做 cookie 中。</p>
<p>主要方法：session（options）</p>
<p>通过 option 来设置 session 存储，除了 session ID 外，session 中的任何数据都不存储在 cookie 中。</p>
<p>常见的options：</p>
<blockquote>
<ul>
<li>cookie 的 httpOnly属性：如果您在cookie中设置了httpOnly属性，那么通过 <strong>JS脚本</strong> 将无法读取到cookie信息，无法用 document.cookie 来打出 cookie 的内容。这样能有效的放置xss攻击。</li>
<li>cookie 的  secure 属性：secure 属性是说，如果一个 cookie 被设置了secure=true，那么这个 cookie 只能用 https协议发送给服务器。用http协议是不能发送的。换句话说，cookie 是在 https的情况下创建的。</li>
<li>secret： 密钥，用来生成签名。</li>
<li>resave： 即使 session 未改变，也要重新保存一下。</li>
<li>saveUninitialize：在没有session值的时候，是否要自动初始化一个。</li>
<li>cookie：{ secure： true } 要加密或签名</li>
</ul>
</blockquote>
<p>express-session 的分析：</p>
<p>主要关注的问题：</p>
<ol>
<li>怎么产生 session</li>
<li>怎么去拿到 session</li>
<li>怎么去保存 session</li>
<li>怎样去清除 session</li>
</ol>
<p><strong>登录</strong></p>
<p>明文存储用户密码是一件很不机智的事情，包括 CSDN 在内的一系列组织都出现过大量用户账号密码泄漏的事故，如果明文存储密码，画面太美不敢看。</p>
<p>我们使用 Node.js 自带的 <code>crypto</code> 模块中的 <code>pbkdf2</code> 算法，加密用户的密码，在登录时取出密码进行比对。</p>
<p>使用时要注意： </p>
<ol>
<li>不能使用 <code>pbkdf2Sync</code> 方法；</li>
<li>由于该算法耗时较长，要进行异步处理。</li>
</ol>
<hr>
<p><code>cookis</code> ：服务器返回的 <code>setCookie</code> 字段，被浏览器嗅探到然后保存，以后每次请求同一域名的时候，http请求体中带上cookie。</p>
<p>不可能搞前端加密，前端加密，加密算法都明文写在网页里面，尤其是加密算法的<code>key</code> ，这实际上是一种掩耳盗铃的做法。</p>
<p><strong>加密的密钥永远不要放在前端</strong>。</p>
<p><code>res.set(&#39;Set-Cookie&#39;, &#39;username=xiaoli&#39;)</code></p>
<p>cookie 各个条目之间用 <code>;</code> 分隔。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/node/" rel="tag"># node</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/08/17/node相关/" rel="next" title="node相关">
                <i class="fa fa-chevron-left"></i> node相关
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/09/27/react总览/" rel="prev" title="react总览">
                react总览 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Overview
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          
            <img class="site-author-image" itemprop="image"
              src="/images/avatar.png"
              alt="Ak-lee" />
          
            <p class="site-author-name" itemprop="name">Ak-lee</p>
            <p class="site-description motion-element" itemprop="description">start from zero</p>
        </div>

        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
            
              <a href="/archives/">
            
                <span class="site-state-item-count">27</span>
                <span class="site-state-item-name">posts</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">15</span>
                <span class="site-state-item-name">tags</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#node"><span class="nav-number">1.</span> <span class="nav-text">node</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#process-env-的小坑"><span class="nav-number">1.0.1.</span> <span class="nav-text">process.env 的小坑</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#node-server"><span class="nav-number">1.0.2.</span> <span class="nav-text">node server</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Express-项目初始化"><span class="nav-number">1.1.</span> <span class="nav-text">Express 项目初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Express-的-MVC"><span class="nav-number">1.1.1.</span> <span class="nav-text">Express 的 MVC</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MongoDB-数据库"><span class="nav-number">1.2.</span> <span class="nav-text">MongoDB 数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#增删改查"><span class="nav-number">1.2.1.</span> <span class="nav-text">增删改查</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#文档之间的关系"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">文档之间的关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sort-排序-和投影"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">sort(排序) 和投影</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Mongoose"><span class="nav-number">1.3.</span> <span class="nav-text">Mongoose</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Document-的方法"><span class="nav-number">1.3.0.1.</span> <span class="nav-text">Document 的方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Node-js-中的异步"><span class="nav-number">1.4.</span> <span class="nav-text">Node.js 中的异步</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#错误处理和日志"><span class="nav-number">1.5.</span> <span class="nav-text">错误处理和日志</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#日志文件"><span class="nav-number">1.5.0.1.</span> <span class="nav-text">日志文件</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#鉴权（用户登录与注册）"><span class="nav-number">1.6.</span> <span class="nav-text">鉴权（用户登录与注册）</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ak-lee</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.2</div>



<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
<span id="busuanzi_container_site_pv">
    |  您是本站第 <span id="busuanzi_value_site_pv"></span> 位访问者
</span>
        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>


  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  








  





  

  

  

  
  


  

  

</body>
</html>
