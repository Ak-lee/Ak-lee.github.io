<!DOCTYPE html>




<html class="theme-next mist" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="node," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="为什么选择 npm script?npm script 相比 grunt、gulp 这些工具简单很多，因为它消除了这些构建工具的抽象层，并带给我们更大的自由度。随着社区的发展，这种基础工具你都可以信手拈来。 初始 npm script首先介绍创建 package.json 文件的科学方法，目标是掌握 npm init 命令。然后，通过在终端中运行自动生成的 test 命令，详细讲解 npm 脚本基">
<meta name="keywords" content="node">
<meta property="og:type" content="article">
<meta property="og:title" content="npm_script前端工作流">
<meta property="og:url" content="http://yoursite.com/2018/10/07/npm-script前端工作流/index.html">
<meta property="og:site_name" content="Ak-lee">
<meta property="og:description" content="为什么选择 npm script?npm script 相比 grunt、gulp 这些工具简单很多，因为它消除了这些构建工具的抽象层，并带给我们更大的自由度。随着社区的发展，这种基础工具你都可以信手拈来。 初始 npm script首先介绍创建 package.json 文件的科学方法，目标是掌握 npm init 命令。然后，通过在终端中运行自动生成的 test 命令，详细讲解 npm 脚本基">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2018-10-07T08:50:52.363Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="npm_script前端工作流">
<meta name="twitter:description" content="为什么选择 npm script?npm script 相比 grunt、gulp 这些工具简单很多，因为它消除了这些构建工具的抽象层，并带给我们更大的自由度。随着社区的发展，这种基础工具你都可以信手拈来。 初始 npm script首先介绍创建 package.json 文件的科学方法，目标是掌握 npm init 命令。然后，通过在终端中运行自动生成的 test 命令，详细讲解 npm 脚本基">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.2',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/10/07/npm-script前端工作流/"/>





  <title>npm_script前端工作流 | Ak-lee</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Ak-lee</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">前端修炼中</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Startseite
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            Über
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archiv
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/07/npm-script前端工作流/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ak-lee">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ak-lee">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">npm_script前端工作流</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-10-07T16:47:38+08:00">
                2018-10-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="为什么选择-npm-script"><a href="#为什么选择-npm-script" class="headerlink" title="为什么选择 npm script?"></a>为什么选择 npm script?</h1><p>npm script 相比 grunt、gulp 这些工具简单很多，因为它消除了这些构建工具的抽象层，并带给我们更大的自由度。随着社区的发展，这种基础工具你都可以信手拈来。</p>
<h2 id="初始-npm-script"><a href="#初始-npm-script" class="headerlink" title="初始 npm script"></a>初始 npm script</h2><p>首先介绍创建 package.json 文件的科学方法，目标是掌握 npm init 命令。然后，通过在终端中运行自动生成的 test 命令，详细讲解 npm 脚本基本执行流程。然后，动手给项目增加 eslint 命令，熟悉创建自定义命令的基本流程。</p>
<h3 id="用-npm-init-快速创建项目"><a href="#用-npm-init-快速创建项目" class="headerlink" title="用 npm init 快速创建项目"></a>用 npm init 快速创建项目</h3><p>开始探索 npm script 之前，我们先聊聊这些 scripts 所依赖的文件 package.json， 以它为基础的 npm 则是 node.js 社区蓬勃发展的顶梁柱。</p>
<p>npm 为我们提供了快速创建 package.json 文件的命令 npm init ,执行该命令会问几个基本问题，如包名称、版本号、作者信息、入口文件、仓库地址、许可协议等，多数问题已经提供了默认值，你可以在问题后敲回车接受默认值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">package name: (hello-npm-script)</div><div class="line">version: (0.1.0)</div><div class="line">description: hello npm script</div><div class="line">entry point: (index.js)</div><div class="line">test command:</div><div class="line">git repository:</div><div class="line">keywords: npm, script</div><div class="line">license: (MIT)</div></pre></td></tr></table></figure>
<p>上面的例子指定了描述（description）和关键字（keywords）两个字段，基本问题回答完毕之后 npm 会把 package.json 文件内容打出来供你确认：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attr">"name"</span>: <span class="string">"hello-npm-script"</span>,</div><div class="line">    <span class="attr">"version"</span>: <span class="string">"0.1.0"</span>,</div><div class="line">    <span class="attr">"decription"</span>: <span class="string">"hello npm script"</span>,</div><div class="line">    <span class="attr">"main"</span>: <span class="string">"index.js"</span>,</div><div class="line">    <span class="attr">"scripts"</span>: &#123;</div><div class="line">        <span class="attr">"test"</span>: <span class="string">"echo \"Error: no test specified\" "</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">"keywords"</span>: [</div><div class="line">        <span class="string">"npm"</span>,</div><div class="line">        <span class="string">"script"</span></div><div class="line">    ],</div><div class="line">    <span class="attr">"author"</span>: <span class="string">""</span>，</div><div class="line">    <span class="string">"license"</span>: <span class="string">"MIT"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>按回车确认就能把 package.json 的内容写到文件系统，如果要修改 package.json ，可以直接用编辑器修改，或者再次运行 npm init , npm 默认不会覆盖修改里面已经存在的信息。</p>
<blockquote>
<p>嫌上面的初始化方式太罗嗦？ 你可以使用 <code>npm init -f</code> (意指 –force, 或者使用 –yes) 告诉 npm 跳过参数问答环节，快速生成 package.json。</p>
</blockquote>
<p>初始化 package.json 时字段默认值是可以自己配置的，细心的同学可能已经发现，我上面的默认版本号是 0.1.0 , 而 npm 默认的版本号是 0.1.0，可以用下面的命令去修改默认配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">npm config set init.author.email &quot;laklc295@gmail.com&quot;</div><div class="line">npm config set init.author.name &quot;ak-Lee&quot;</div><div class="line">npm config set init.author.url &quot;https://github.com/Ak-lee&quot;</div><div class="line">npm config set init.license &quot;MIT&quot;</div><div class="line">npm config set init.version &quot;0.1.0&quot;</div></pre></td></tr></table></figure>
<blockquote>
<p>将默认配置和 -f 参数结合使用，能让你用最短的时间创建 package.json 文件，快去自己试试吧。</p>
</blockquote>
<p>严肃的工程师都会使用 Git 对源代码进行版本管理，在 npm init 的基础上，你可以使用 <code>git init</code> 来我初始化 git 仓库，不再展开。</p>
<p>纸上得来终觉浅，想掌握 npm script，请打开终端，执行如下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">cd ~</div><div class="line">mkdir hello-npm-script &amp;&amp; cd $_</div><div class="line">npm init</div><div class="line">npm init -f</div></pre></td></tr></table></figure>
<h3 id="用-npm-run-执行任意命令"><a href="#用-npm-run-执行任意命令" class="headerlink" title="用 npm run 执行任意命令"></a>用 npm run 执行任意命令</h3><p>使用 npm init 创建的 package.json 文件中包含了 scripts 字段：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">"scripts": &#123;</div><div class="line">    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在终端中运行 <code>npm run test</code> ，能看到 Error：no test specified 的输出。<code>npm run test</code> 可以简写为 <code>npm test</code> ，或更简单的 <code>npm t</code> 得到的结果几乎是相同的。 <code>npm test</code> 顾名思义，就是运行项目的测试，实际用法在实战环节会有介绍。</p>
<p>和 <code>test</code> 类似，<code>start</code> 也是 npm 内置的支持的命令，但是需要先在 scripts 字段中声明该脚本的实际内容，如果没声明就执行 <code>npm start</code> , 会直接报错。</p>
<p>那么， npm 是如何管理和执行各种 scripts 的呢？作为 npm 内置的核心功能之一，<code>npm run</code> 实际上是 <code>npm run-script</code> 命令的简写。当我们运行 <code>npm run xxx</code> 时，基本步骤如下：</p>
<ol>
<li>从 <code>package.json</code> 文件中读取 <code>scripts</code> 对象里的全部配置；</li>
<li>以传给 <code>npm run</code> 的第一个参数作为键，本例中为 <code>xxx</code>, 在 <code>scripts</code> 对象里面获取对应的值作为接下来要执行的命令，如果没找到直接报错。</li>
<li>在系统默认的 shell 中执行尚需命令，系统默认的 shell 通常是 bash，windows环境下可能略有不同。</li>
</ol>
<p>注意，上面这是简化流程，更复杂的钩子文件机制后面单独章节介绍。</p>
<p>举例来说，如果 package.json 文件内容如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attr">"name"</span>: <span class="string">"hello-npm-script"</span>,</div><div class="line">    <span class="attr">"devDependencies"</span>: &#123;</div><div class="line">        <span class="attr">"eslint"</span>: <span class="string">"latest"</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">"scipts"</span>: &#123;</div><div class="line">        <span class="attr">"eslint"</span>: <span class="string">"eslint **.js"</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果不带任何参数执行 <code>npm run</code> ，它会列出可执行的所有命令，比如下面这样：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Available scripts in the myproject package:</div><div class="line">	eslint</div><div class="line">		eslint **.js</div></pre></td></tr></table></figure>
<p>如果运行 <code>npm run eslint</code> ，npm 会在 shell 中运行 <code>eslint **.js</code></p>
<p>有没有好奇上面的 eslint 命令是从哪里来的？<strong>其实 npm 在执行指定 script 之前会把 <code>node_modules/.bin</code> 加到环境变量 $PATH 的前面</strong>，这意味着任何内含可执行文件的  npm 依赖都可以在 npm scripts 中直接调用，换句话说，你不需要在 npm script 中加上可执行文件的完整路径，比如 <code>./node_modules/.bin/eslint **.js</code></p>
<h3 id="创建自定义-npm-script"><a href="#创建自定义-npm-script" class="headerlink" title="创建自定义 npm script"></a>创建自定义 npm script</h3><p>知道如何运行 npm script 之后，接下来我们在 hello-npm-script 项目中添加有实际用途的 eslint 脚本，eslint 脚本是社区接受度比较高的 javascript 风格检查工具，有大把现成的规则集可供你选择，如 google、airbnb。</p>
<p>在新项目或任何现有项目中添加 eslint 自定义脚本的步骤如下：</p>
<p><strong>1. 准备被检查的代码</strong></p>
<p>要做代码检查，我们必须有代码，创建 index.js 文件，输入如下内容：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> str = <span class="string">'some value'</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'some log'</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>2. 添加 eslint 依赖</strong></p>
<p>执行如下命令将 eslint 添加为 <code>devDependenciesL</code> :</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install eslint -D</div></pre></td></tr></table></figure>
<p><strong>3. 初始化 eslint 配置</strong></p>
<p>用 eslint 做检查需要配置规则集，存放规则集的文件就是配置文件，使用如下文件生成配置文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./node_modules/.bin/eslint --init</div></pre></td></tr></table></figure>
<blockquote>
<p>TIP: 把 eslint 安装为项目依赖而非全局命令，项目可移植性更高。</p>
</blockquote>
<p>在命令行中提示中选择 Answer questions about your style, 回答几个问题，答案可以根据自己的偏好。</p>
<p>回车之后根目录下就有了 <code>.eslintrc.js</code> 配置文件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">    env: &#123;</div><div class="line">        es6: <span class="literal">true</span>,</div><div class="line">        node: <span class="literal">true</span>,</div><div class="line">    &#125;,</div><div class="line">    extends: <span class="string">'eslint: recommended'</span>,</div><div class="line">    rules: &#123;</div><div class="line">        indent: [<span class="string">'error'</span>, <span class="number">4</span>],</div><div class="line">        <span class="string">'linebreak-style'</span>: [<span class="string">'error'</span>, <span class="string">'unix'</span>],</div><div class="line">        quotes: [<span class="string">'error'</span>, <span class="string">'single'</span>],</div><div class="line">        semi: [<span class="string">'error'</span>, <span class="string">'always'</span>]</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>4. 添加 eslint 命令</strong></p>
<p>在 <code>package.json</code> 的 <code>scripts</code> 字段中新增命令 <code>eslint</code>:</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attr">"scripts"</span>: &#123;</div><div class="line">        <span class="attr">"eslint"</span>: <span class="string">"eslint *.js"</span>,</div><div class="line">        <span class="attr">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>手动修改 package.json 时一定要注意语法正确</strong></p>
<p><strong>5. 运行 eslint 命令</strong></p>
<p>执行 <code>npm run eslint</code> ，可以看到，按照官方推荐的规则代码李有三处不符合规范的地方。</p>
<h3 id="eslint-完成-react、vue-js-代码的检查"><a href="#eslint-完成-react、vue-js-代码的检查" class="headerlink" title="eslint 完成 react、vue.js 代码的检查"></a>eslint 完成 react、vue.js 代码的检查</h3><p>如果需要结合 eslint 检查主流前端框架 react、vue.js ，下面提供两条线索，因为官方仓库的 README 就可以作为入门文档，仔细读读相信绝大多数同学都能配置好。</p>
<p>使用 <code>eslint-plugin-react</code> 检查 <code>react</code> 代码，使用 <code>react-plugin-react-native</code> 检查 react-native 代码，如果你比较懒，可以直接使用 <code>eslint-config-airbnb</code>, 里面内置了 <code>eslint-plugin-react</code>, 新人常遇到 <code>peerDependencies</code> 安装失败的问题可参照 npmjs 主页上方法解决：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    export PKG=eslint-config-airbnb;</div><div class="line">    npm info "$PKG@latest" peerDependencies --json | command sed 's/[\&#123;\&#125;,]//g ; s/: /@/g' | xargs npm install --save-dev "$PKG@latest"</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>推荐使用 vue.js 官方的 eslint 插件： <code>eslint-plugin-vue</code> 来检查 vue.js 代码，具体的配置方法官方 README 写的清晰明了，这里就不赘述了。</p>
<p>上面的几种 eslint 规则集的官方仓库都列出了各自支持的规则，如果你需要关闭某些规则可以直接在自己的 <code>.eslintrc*</code> 里面的 rules 中配置。</p>
<h2 id="运行多个-npm-script-的各种姿势"><a href="#运行多个-npm-script-的各种姿势" class="headerlink" title="运行多个 npm script 的各种姿势"></a>运行多个 npm script 的各种姿势</h2><p>前端项目通常会包括多个 npm script ，对多个命令进行编排是很自然的需求，有时候需要将多个命令串行，即脚本遵循严格的执行顺序；有时候则需要让它们并行来提高速度，比如不相互阻塞的 npm script。社区中也有比 npm 内置的多命令运行机制更好用的解决方案： <code>npm-run-all</code></p>
<h3 id="哪来那么多命令？"><a href="#哪来那么多命令？" class="headerlink" title="哪来那么多命令？"></a>哪来那么多命令？</h3><p>通常来说，前端项目会包含 js 、css、less、scss、json、markdown 等格式的文件，为保障代码质量给不同的代码添加检查是很有必要的，代码检查不仅保障代码没有低级的语法错误，还可确保代码都遵守社区的最佳实践和一致的编码风格，在团队协作中尤其有用，即使是个人项目，加上代码检查，也会提高你的效率和质量。</p>
<p>我通常会给前端项目加上下面 4 中代码检查：</p>
<ul>
<li>eslint， 可定制的 js 代码检查。</li>
<li>stylelint，可定制的样式文件检查，支持 css、less、scss；</li>
<li>jsonlint，json 文件语法检查，才过坑的同学会清楚，json 文件语法错误会导致各种失败。</li>
<li>markdown-cli， Markdown 文件最佳实践检查，个人偏好；</li>
</ul>
<p>需要注意的是，html 代码也应该检查，但是工具支持薄弱，就略过不表。此外，为代码添加必要的单元测试也是质量保障的重要手段，常用的单元检测技术栈是：</p>
<ul>
<li>mocha，测试用例组织，测试用例运行和结果收集的框架；</li>
<li>chai，测试断言库，必要的时候可以结合 sinon 使用；</li>
</ul>
<blockquote>
<p><strong>TIP</strong> : 测试工具如 tap、ava 也都提供了命令行接口，能很好的集成到 npm script 中，原理是相通的。</p>
</blockquote>
<p>包含了基本的代码检查、单元测试命令的 package.json 如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"name"</span>: <span class="string">"hello-npm-script"</span>,</div><div class="line">  <span class="attr">"version"</span>: <span class="string">"0.1.0"</span>,</div><div class="line">  <span class="attr">"main"</span>: <span class="string">"index.js"</span>,</div><div class="line">  <span class="attr">"scripts"</span>: &#123;</div><div class="line">    <span class="attr">"lint:js"</span>: <span class="string">"eslint *.js"</span>,</div><div class="line">    <span class="attr">"lint:css"</span>: <span class="string">"stylelint *.less"</span>,</div><div class="line">    <span class="attr">"lint:json"</span>: <span class="string">"jsonlint --quiet *.json"</span>,</div><div class="line">    <span class="attr">"lint:markdown"</span>: <span class="string">"markdownlint --config .markdownlint.json *.md"</span>,</div><div class="line">    <span class="attr">"test"</span>: <span class="string">"mocha tests/"</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">"devDependencies"</span>: &#123;</div><div class="line">    <span class="attr">"chai"</span>: <span class="string">"^4.1.2"</span>,</div><div class="line">    <span class="attr">"eslint"</span>: <span class="string">"^4.11.0"</span>,</div><div class="line">    <span class="attr">"jsonlint"</span>: <span class="string">"^1.6.2"</span>,</div><div class="line">    <span class="attr">"markdownlint-cli"</span>: <span class="string">"^0.5.0"</span>,</div><div class="line">    <span class="attr">"mocha"</span>: <span class="string">"^4.0.1"</span>,</div><div class="line">    <span class="attr">"stylelint"</span>: <span class="string">"^8.2.0"</span>,</div><div class="line">    <span class="attr">"stylelint-config-standard"</span>: <span class="string">"^17.0.0"</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="让多个-npm-script-串行？"><a href="#让多个-npm-script-串行？" class="headerlink" title="让多个 npm script 串行？"></a>让多个 npm script 串行？</h3><p>在我们运行测试之前确保我们的代码都通过代码风格检查会是比较不错的实践，这也是让多个 npm script 串行的典型用例，实现方式也比较简单，只需要用 <code>&amp;&amp;</code> 符号把多条 npm script 按先后顺序串起来即可，觉察到我们的项目，修改如下所示：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">-	"test": "mocha tests/"</div><div class="line">+	"test": "npm run lint:js &amp;&amp; npm run lint:css &amp;&amp; npm run lint:json &amp;&amp; npm run lint:markdown &amp;&amp; mocha tests/"</div></pre></td></tr></table></figure>
<p>然后直接执行 <code>npm test</code> 或 <code>npm t</code> , 从输出可以看到子命令的执行顺序是严格按照我们在 scripts 中声明的先后顺序来的。</p>
<p>需要注意的是，串行执行的时候如果前序命令失败（通常进程退出码非 0），后续全部命令都会终止。</p>
<h3 id="让多个-npm-script-并行？"><a href="#让多个-npm-script-并行？" class="headerlink" title="让多个 npm script 并行？"></a>让多个 npm script 并行？</h3><p>在严格串行的情况下，我们必须要确保代码中没有编码规范问题才能运行后测试，在某些时候可能并不是我们想要的，因为我们真正需要的是，代码变更时同时给出测试结果和测试运行结果。这就需要把子命令的运行从串行改成并行，实现方式更简单，把连接多条命令的 <code>&amp;&amp;</code> 符号替换为 <code>&amp;</code> 即可。</p>
<p>代码变更如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">-	&quot;test&quot;: &quot;npm run lint:js &amp;&amp; npm run lint:css &amp;&amp; npm run lint:json &amp;&amp; npm run lint:markdown &amp;&amp; mocha tests/&quot;</div><div class="line">+	&quot;test&quot;: &quot;npm run lint:js &amp; npm run lint:css &amp; npm run lint:json &amp; npm run lint:markdown &amp; mocha tests/&quot;</div></pre></td></tr></table></figure>
<p>npm 内置的支持多条命令并行跟 js 里面同时发起多个异步请求非常类似，它值负责触发多条命令，而不管结果的收集，如果并行的命令执行时间差异非常大，就可能造成慢的命令在调用进程退出之后才结束。</p>
<p>答案也很简单，在命令的最后增加 <code>&amp; wait</code> ，即可，这样我们的 test 命令长这样：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm run lint:js &amp; npm run lint:css &amp; npm run lint:json &amp; npm run lint:markdown &amp; mocha tests/ &amp; wait</div></pre></td></tr></table></figure>
<p>加上 <code>wait</code> 的额外好处是，如果我们在任何子命令中启动了长时间运行的进程，比如启用了 mocha 的 –watch 配置，就可以使用 ctrl + c 来结束进程，如果没加的话，你就没办法之间直接结束启动到后台的进程。</p>
<h3 id="有没有更好的管理方式？"><a href="#有没有更好的管理方式？" class="headerlink" title="有没有更好的管理方式？"></a>有没有更好的管理方式？</h3><p>有强迫症的同学可能会觉得像上面这样用原生方式来运行多条命令很臃肿，幸运的是，我们可以使用 <code>npm-run-all</code> 实现更轻量和简洁的多命令运行。</p>
<p>用如下命令将 <code>npm-run-all</code> 添加到项目依赖中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm i npm-run-all -D</div></pre></td></tr></table></figure>
<p>然后修改 package.json 实现多条命令的串行执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">-    &quot;test&quot;: &quot;npm run lint:js &amp; npm run lint:css &amp; npm run lint:json &amp; npm run lint:markdown &amp; mocha tests/ &amp; wait&quot;</div><div class="line">+    &quot;mocha&quot;: &quot;mocha tests/&quot;,</div><div class="line">+    &quot;test&quot;: &quot;npm-run-all lint:js lint:css lint:json lint:markdown mocha&quot;</div></pre></td></tr></table></figure>
<p><code>npm-runb-all</code> 还支持通配符匹配分组的 npm script, 上面的脚本可以进一步简化成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">-    &quot;test&quot;: &quot;npm-run-all lint:js lint:css lint:json lint:markdown mocha&quot;</div><div class="line">+    &quot;test&quot;: &quot;npm-run-all lint:* mocha&quot;</div></pre></td></tr></table></figure>
<p>如何让多个 npm script 并行执行？ 也很简单“：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">-    &quot;test&quot;: &quot;npm-run-all lint:* mocha&quot;</div><div class="line">+    &quot;test&quot;: &quot;npm-run-all --parallel lint:* mocha&quot;</div></pre></td></tr></table></figure>
<p><code>--parallel</code> 意思是 并行的。</p>
<p>并行执行的时候，我们并不需要在后面增加 <code>&amp; wait</code> ，因为 <code>npm-run-all</code> 已经帮哦我们做了。</p>
<blockquote>
<p><strong>TIP</strong>： <code>npm-run-all</code> 还提供了很多配置项支持更复杂的命令编排，比如多个命令并行之后接串行的命令，该兴趣的同学请阅读<a href="https://github.com/mysticatea/npm-run-all/blob/HEAD/docs/npm-run-all.md" target="_blank" rel="external">文档</a></p>
</blockquote>
<h2 id="给-npm-script-传递参数和添加注释"><a href="#给-npm-script-传递参数和添加注释" class="headerlink" title="给 npm script 传递参数和添加注释"></a>给 npm script 传递参数和添加注释</h2><p>本小节会介绍 3 个知识点：给 npm script 传递参数以减少重复的 npm script； 增加注释提高 npm script 脚本的可读性； 控制运行时日志的输出能让你专注在重要信息上。</p>
<h4 id="给-npm-script-传递参数"><a href="#给-npm-script-传递参数" class="headerlink" title="给 npm script 传递参数"></a>给 npm script 传递参数</h4><p>eslint 内置了代码风格自动修复模式，只需给它传入 <code>--fix</code> 参数即可，在 scripts 中声明检查代码命令的同时你可能也需要声明修复代码的命令，面对这种需求，大多数同学核能会忍不住复制粘贴，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&quot;lint:js&quot;: &quot;eslint *.js&quot;</div><div class="line">+	&quot;lint:js:fix&quot;: &quot;eslint *.js --fix&quot;</div></pre></td></tr></table></figure>
<p>在 <code>lint:js</code> 命令比较短的时候复制粘贴的方法简单粗暴有效，但是当 <code>lint:js</code> 命令变的很长之后，难免后续会有人改了 <code>lint:js</code> 而忘记修改 <code>lint:js:fix</code> , 更健壮的做法是，在运行 npm script 时给定额外的参数，代码修改如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="string">"lint:js"</span>: <span class="string">"eslint *.js"</span></div><div class="line">+	“lint:js:fix”: <span class="string">"npm run lint:js -- --fix"</span></div></pre></td></tr></table></figure>
<p>要格外注意 <code>--fix</code> 参数前面的 <code>--</code> 分隔符，意指要给 <code>npm run lint:js</code>  实际要指向的命令传递额外的参数。</p>
<blockquote>
<p><strong>TIP</strong>: 如果你不想单独声明 <code>lint:js:fix</code> 命令，在需要的时候直接运行： <code>npm run lint:js -- --fix</code> 来实现同样的效果。</p>
</blockquote>
<h4 id="给-npm-script-添加注释"><a href="#给-npm-script-添加注释" class="headerlink" title="给 npm script 添加注释"></a>给 npm script 添加注释</h4><p>如果 package.json 中的 scripts 越来越多，或者出现复杂的编排命令，你可能需要给它们添加注释以保障代码可读性，但 json 天然是不支持添加注释的，下面是两种比较 trick 的方式。</p>
<p>第一种方式是，package.json 中增加 <code>//</code> 为键的值，注释就可以写在对应的值里面，npm 会忽略这种键。比如，我们想要给 test 命令添加注释，按如下方式添加：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&quot;//&quot;: &quot;运行所有代码检查和单元测试&quot;，</div><div class="line">&quot;test&quot;: &quot;npm-run-all -parallel lint: * mocha&quot;</div></pre></td></tr></table></figure>
<p>这种方法的明显不足是，<code>npm run</code>(即不带执行命令的run) 列出来的命令列表不能把注释和实际命令对应上，如果你声明了多个，npm run 只会列出最后那个。</p>
<p>另一种方式是直接在 script 声明中做手脚，因为命令的本质是 shell 命令（适用于 linux 平台），我们可以在命令前面加上注释，具体做法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&quot;test&quot;: &quot;# 运行所有代码检查和单元测试 \n    npm-run-all --parallel lint:* mocha&quot;</div></pre></td></tr></table></figure>
<p>注意注释后面的换行符 <code>\n</code> 和多余的空格，换行符是用于将注释和命令分隔开，这样命令就相当于微型的 shell 脚本，多余的空格是为了控制缩进，也可以用制表符 <code>\t</code> 替代。这种做法能让 <code>npm run</code> 列出来的命令更美观，但是 scripts 声明阅读起来不那么整齐美观。</p>
<p>上面两种方式都有明显的缺陷，个人建议的更优方案还是把复杂的命令剥离到单独的文件中管理，在单独的文件中可以自由的给它添加注释，详见后续章节。</p>
<h3 id="调整-npm-script-运行时日志输出"><a href="#调整-npm-script-运行时日志输出" class="headerlink" title="调整 npm script 运行时日志输出"></a>调整 npm script 运行时日志输出</h3><p>在运行 npm script 出现问题时你需要有能力去调试它，某些情况下你需要让 <code>npm script</code> 以静默的方式运行，这类需求可通过控制运行是日志输出级别来实现。</p>
<p>日志级别控制参数有好几个，简单举例如下：</p>
<h4 id="默认日志输出级别"><a href="#默认日志输出级别" class="headerlink" title="默认日志输出级别"></a>默认日志输出级别</h4><p>即不加任何日志控制参数得到的输出，可能是你最常用的，能看到执行命令、命令执行的结果。</p>
<h4 id="显示尽可能少的有用信息"><a href="#显示尽可能少的有用信息" class="headerlink" title="显示尽可能少的有用信息"></a>显示尽可能少的有用信息</h4><p>结合其他工具调用 <code>npm script</code> 的时候比较有用，需要使用 <code>--loglevel silent</code> , 或者 <code>--silent</code>， 或者更简单的 <code>-s</code> 来控制。如 <code>npm test -s</code></p>
<p>如果执行各种 lint script 的时候启用了 <code>-s</code> 配置，代码都符合规范的话，你不会看到任何输出，这就是 <strong>没有消息就是最好的消息</strong> 的由来。</p>
<h4 id="显示尽可能多的运行状态"><a href="#显示尽可能多的运行状态" class="headerlink" title="显示尽可能多的运行状态"></a>显示尽可能多的运行状态</h4><p>排查脚本问题的时候比较有用，需要使用 <code>--loglevel verbose</code> ，或者 <code>--verbose</code> ，或者更简单的 <code>-d</code> 来控制，这个日志级别会显示的打印每个步骤的参数，返回值等。</p>
<h1 id="进阶篇"><a href="#进阶篇" class="headerlink" title="进阶篇"></a>进阶篇</h1><h2 id="使用-npm-script-的钩子"><a href="#使用-npm-script-的钩子" class="headerlink" title="使用 npm script 的钩子"></a>使用 npm script 的钩子</h2><p>为了方便开发者自定义，npm  script 的设计者为命令的执行增加了类似声明周期的机制，具体来说就是 <code>pre</code> 和 <code>post</code> 钩子脚本。这种特性在某些操作钱需要做检查、某些操作后需要做清理的情况下非常有用。</p>
<p>具体来说，运行 <code>npm run test</code> 的时候，分 3 个阶段：</p>
<ol>
<li>检查 scripts 对象中时候存在 <code>pretest</code> 命令，如果有，先执行该命令；</li>
<li>检查是否有 test 命令，有的话运行 test 命令，没有的话报错；</li>
<li>检查是否存在 <code>posttest</code> 命令，如果有，执行 <code>posttest</code> 命令；</li>
</ol>
<p>到目前为止我们所覆盖的前端工作流包含了代码检查和测试自动化运行环节，衡量测试效果的重要指标是测试覆盖率，而手机覆盖率也非常简单，下面逐步讲解如何把代码检查、测试运行、覆盖率收集这些步骤串起来。</p>
<h3 id="改造-test-命令"><a href="#改造-test-命令" class="headerlink" title="改造 test 命令"></a>改造 test 命令</h3><p>首先，我们基于钩子机制对现有的 scripts 做以下 3 点重构，把代码检查和测试串起来：</p>
<ul>
<li>增加简单的 lint 命令，并行运行所有的 lint 子命令；</li>
<li>增加 pretest 钩子，在其中运行 lint 命令；</li>
<li>把 test 替换成更简单的 <code>mocha tests/</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&quot;lint&quot;: &quot;npm-run-all --parallel lint:*&quot;,</div><div class="line">&quot;lint:js&quot;: &quot;eslint *.js&quot;,</div><div class="line">&quot;lint:js:fix&quot;: &quot;npm run lint:js -- --fix&quot;,</div><div class="line">&quot;lint:css&quot;: &quot;stylelint *.less&quot;,</div><div class="line">&quot;lint:json&quot;: &quot;jsonlint --quiet *.json&quot;,</div><div class="line">&quot;lint:markdown&quot;: &quot;markdownlint --config .markdownlint.json *.md&quot;,</div><div class="line">&quot;pretest&quot;: &quot;npm run lint&quot;,</div><div class="line">&quot;test&quot;: &quot;mocha tests/&quot;,</div></pre></td></tr></table></figure>
<h3 id="增加覆盖率收集"><a href="#增加覆盖率收集" class="headerlink" title="增加覆盖率收集"></a>增加覆盖率收集</h3><p>接下来我们把运行测试和覆盖率收集串起来，具体做法是：增加覆盖率收集的命令，并且覆盖率收集完毕之后自动打开 html 版本的覆盖率报告。要实现目标，我们需要引入两个新工具：</p>
<ol>
<li>覆盖率收集工具 <code>nyc</code> ,是覆盖率收集工具 <code>istanbul</code> 的命令行版本，<code>istanbul</code> 支持生成各种格式的覆盖率报告；</li>
<li>打开 html 文件的工具 <code>open-cli</code> , 是能够打开任意程序的工具 <code>opn</code> 的命令行版本，作者是前端社区非常高产的 Sindre Sorhus, 它在 npm 上发布了超过 1000 个包，并且质量还都不错。</li>
</ol>
<p>使用如下命令安装依赖：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm i nyc open-cli -D</div></pre></td></tr></table></figure>
<p>然后在 package.json 增加 nyc 的配置，告诉 nyc 该忽略哪些文件。最后是在 scripts 中新增 3 条命令：</p>
<ol>
<li>precover， 收集覆盖率之前把之前的覆盖率报告目录清理掉；</li>
<li>cover， 直接调用 nyc ，让其生成 html 格式的覆盖率报告；</li>
<li>postcover ，清理掉临时文件，并且在浏览器中预览覆盖率报告；</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">"scripts": &#123;</div><div class="line">    "precover": "rm -rf coverage",</div><div class="line">    "cover": "nyc --reporter=html npm test"</div><div class="line">    "postcover": "rm -rf .nyc_output &amp;&amp; coverage/index.html"</div><div class="line">&#125;,</div><div class="line">"devDependencies":  &#123;</div><div class="line">    "npm-run-all": "^4.1.2",</div><div class="line">    "nyc": "^11.3.0",</div><div class="line">    "opn-cli": "^3.1.0",</div><div class="line">    "stylelint": "^8.2.0",.</div><div class="line">    "stylelint-config-standard": "^17.0.0"</div><div class="line">&#125;,</div><div class="line">"nyc": &#123;</div><div class="line">    "exclude": [</div><div class="line">        "**/*.spec.js",</div><div class="line">        <span class="string">".*.js"</span></div><div class="line">    ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>改完之后我们就可以直接运行 <code>npm run cover</code> 了。</p>
<h2 id="在-npm-script-中使用变量"><a href="#在-npm-script-中使用变量" class="headerlink" title="在 npm script 中使用变量"></a>在 npm script 中使用变量</h2><p>npm 为更加高效的执行 npm script 做了大量的优化，在前面我们已经讲到的环境变量特性能让我们在 npm script 中直接调用依赖包里的可执行文件，更强大的是，npm 还提供了 <code>$PATH</code> 之外的更多变量，植入当前正在执行的命令、包的名称和版本号、日志输出的级别等。</p>
<p>DRY（Don’t Repeat Yourself） 是基本编程原则，在 npm script 中使用预定义变量和自定义变量让我们更容易遵从 DRY 原则，因为使用这些变量之后，npm script 就具备了自适应的能力，我们可以直接把积累起来 npm script 使用到其他项目里面，而不用做任何修改。</p>
<h3 id="使用预定义变量"><a href="#使用预定义变量" class="headerlink" title="使用预定义变量"></a>使用预定义变量</h3><p>首先我们来看预定义变量，通过运行 <code>npm run env</code> 就能拿到完整的变量列表，这个列表非常长，这里我们使用 <code>npm run env | grep npm_package | sort</code> 拿到部分排序后的预定义环境变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">// 作者信息...</div><div class="line">npm_package_author_email=wangshijun2010@gmail.com</div><div class="line">npm_package_author_name=wangshijun</div><div class="line">npm_package_author_url=http://github.com/wangshijun</div><div class="line">// 依赖信息...</div><div class="line">npm_package_devDependencies_markdownlint_cli=^0.5.0</div><div class="line">npm_package_devDependencies_mocha=^4.0.1</div><div class="line">npm_package_devDependencies_npm_run_all=^4.1.2</div><div class="line">// 各种 npm script</div><div class="line">npm_package_scripts_lint=npm-run-all --parallel lint:*</div><div class="line">npm_package_scripts_lint_css=stylelint *.less</div><div class="line">npm_package_scripts_lint_js=eslint *.js</div><div class="line">npm_package_scripts_lint_js_fix=npm run lint:js -- --fix</div><div class="line">npm_package_scripts_lint_json=jsonlint --quiet *.json</div><div class="line">// 基本信息</div><div class="line">npm_package_version=0.1.0</div><div class="line">npm_package_gitHead=3796e548cfe406ec33ab837ac00bcbd6ee8a38a0</div><div class="line">npm_package_license=MIT</div><div class="line">npm_package_main=index.js</div><div class="line">npm_package_name=hello-npm-script</div><div class="line">npm_package_readmeFilename=README.md</div><div class="line">// 依赖的配置</div><div class="line">npm_package_nyc_exclude_0=**/*.spec.js</div><div class="line">npm_package_nyc_exclude_1=.*.js</div></pre></td></tr></table></figure>
<p>变量的使用方法遵循 shell 里面的语法，直接在 npm script 给想要引用的变量前面加上 <code>$</code> 符号即可。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;dummy&quot;: &quot;echo $npm_package_name&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>回到我们的项目，测试覆盖率归档是比较常见的需求，因为它方便我们追踪覆盖率的变化趋势，最彻底的做法是归档到 CI 系统里面，对于简单项目，则可以直接归档到文件系统中，即把收集到的覆盖率报告按版本号去存放。</p>
<p>比如，我们在根目录下新建 <code>coverage_archive</code> 目录存储覆盖率归档，并领用变量机制把归档和版本号关联起来。具体的 npm script 修改如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&quot;script&quot;: &#123;</div><div class="line">-   &quot;precover&quot;： &quot;rm -rf coverage&quot;,</div><div class="line">    &quot;cover&quot;: &quot;nyc --reporter=html npm test&quot;,</div><div class="line">-   &quot;postcover&quot;: &quot;rm -rf .nyc_output &amp;&amp; opn coverage/index.html&quot;,</div><div class="line">+	&quot;cover:cleanup&quot;: &quot;rm -rf .nyc_output &amp;&amp; opn coverage/index.html&quot;,</div><div class="line">+	&quot;cover:archive&quot;: &quot;mkdir -p coverage_archive/$npm_package_version &amp;&amp; cp -r coverage/* coverage_archive/$npm_package_version&quot;,</div><div class="line">+ 	&quot;postcover&quot;: &quot;npm run cover:archive &amp;&amp; npm run cover:cleanup &amp;&amp; opn coverage_archive/$npm_package_version/index.html&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>主要改动是：增加 cover:cleanup 和 cover:archive 命令，并且修改 postcover 命令。下面对使用了环境变量的 npm script 稍作解释：</p>
<p>cover:archive 做两两件事：</p>
<ol>
<li><code>mkdir -p coverage_archive/$npm_package_version</code> 准备当前版本号的归档目录；</li>
<li><code>cp -r coverage/* coverage_archive/$npm_package_version</code> 直接复制文件来归档</li>
</ol>
<p>而 postcover 做了 3 件事情：</p>
<ol>
<li><code>npm run cover:archive</code> 归档本次覆盖率报告；</li>
<li><code>npm run cover:cleanup</code>, 清理本次覆盖住报告；</li>
<li><code>opn coverage_archive/$npm_package_version/index.html</code> 直接预览覆盖率报告；</li>
</ol>
<p>配置好了后，我们可以直接运行 <code>npm run cover</code> 来生成满足归档要求的覆盖率报告。</p>
<h3 id="使用自定义变量"><a href="#使用自定义变量" class="headerlink" title="使用自定义变量"></a>使用自定义变量</h3><p>除了预定义变量外，我们还可以在 package.json 中添加自定义变量，并且在 npm script 中使用这些变量。</p>
<p>为把测试覆盖率报告分享给其他同时浏览，我们就不能使用 opn-cli 打开文件了，需要启动简单的 http 服务，把网址发给别人浏览，比如我们约定网址为 <code>http://IP:3000</code> ，这里的 IP 需要替换成自己实际的 IP。</p>
<p><code>http-server</code> 提供了非常轻量的 http 服务，我们先把它添加到 <code>devDependencies</code> 中： </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm i http-server -D	# 等价命令行 npm install http-server --save-dev</div></pre></td></tr></table></figure>
<p>接下来， 在 package.json 增加自定义端口配置和相应的 npm script 命令:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&quot;version&quot;: &quot;0.1.0&quot;,</div><div class="line">&quot;config&quot;: &#123;</div><div class="line">    &quot;port&quot;: 3000</div><div class="line">&#125;,</div><div class="line">&quot;script&quot;: &#123;</div><div class="line">      &quot;cover&quot;: &quot;nyc --reporter=html npm test&quot;,</div><div class="line">-    &quot;postcover&quot;: &quot;npm run cover:archive &amp;&amp; npm run cover:cleanup &amp;&amp; opn coverage_archive/$npm_package_version/index.html&quot;</div><div class="line">+    &quot;cover:serve&quot;: &quot;http-server coverage_archive/$npm_package_version -p $npm_package_config_port&quot;,</div><div class="line">+    &quot;cover:open&quot;: &quot;opn http://localhost:$npm_package_config_port&quot;,</div><div class="line">+    &quot;postcover&quot;: &quot;npm-run-all cover:archive cover:cleanup --parallel cover:serve cover:open&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>关于改动做一下几点解释：</p>
<ul>
<li><p>新增的命令 <code>cover:server</code>  中使用了预定义变量<code>$npm_package_version</code> 和自定义变量 <code>$npm_package_config_port</code></p>
</li>
<li><p>预览覆盖率报告的方式从直接打开修改为打开网址：</p>
<p><code>http://localhost:$npm_package_config_port</code></p>
</li>
<li><p>postcover 命令要做的事情比较多，我们直接使用 npm-run-all 来编排子命令。</p>
</li>
</ul>
<blockquote>
<p><strong>TIP</strong> : 注意这里给 cover:server 和 cover:open 增加了并行参数 <code>--parallel</code>，因为 cover:server  不会自动退出。</p>
<p><strong>TIP</strong>： 可能有人会好奇，是否可以在自定义变量的声明中使用预定义变量，测试之后发现不可以。</p>
</blockquote>
<p>修改完之后，我们再次运行 <code>npm run cover</code> ，终端会在 <code>cover:server</code> 之后进入等待状态；同时浏览器会打开覆盖率报告。</p>
<h2 id="实现命令行自动补全"><a href="#实现命令行自动补全" class="headerlink" title="实现命令行自动补全"></a>实现命令行自动补全</h2><p>当 npm script 里面积累的命令越来越多时，重度命令行用户可能会好奇，能不能实现类似 bash、zsh 里面的命令自动补全？ 答案是肯定的，下面来逐一介绍。</p>
<h4 id="使用-npm-run-直接列出"><a href="#使用-npm-run-直接列出" class="headerlink" title="使用 npm run 直接列出"></a>使用 npm run 直接列出</h4><p>前面的章节有过介绍，不带任何参数运行 npm run 能够列出 scripts 对象中定义的所有命令，在结合管道操作符、less命令（这里的 less 不是 css 领域的 less，而是 linux 里面的工具），即使 scripts 子命令很多我们也能移动自如。试试运行 <code>npm run | less</code> 吧。</p>
<h4 id="把-npm-completion-集成到-shell-中"><a href="#把-npm-completion-集成到-shell-中" class="headerlink" title="把 npm completion 集成到 shell 中"></a>把 npm completion 集成到 shell 中</h4><p>npm 自身提供了自动完成工具 <code>completion</code>，将其集成到 bash 或者 zsh 里也非常容易。</p>
<p>官方文档里面的集成方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">npm completion &gt;&gt; ~/.bashrc</div><div class="line">npm completion &gt;&gt; ~/.zshrc</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>TIP</strong> ： 如果你好奇上面的命令究竟做了什么，尝试直接运行 <code>npm completion</code> ，就能看到它其实在你的配置文件（如 .bashrc 和 .zshrc）中追加了一大坨 shell 。上面命令中的 <code>&gt;&gt;</code> 意思是把前面命令的输出追加到后面的文件中。</p>
</blockquote>
<p>如果你也有代码洁癖，为了保持 .zshrc 或者 .bashrc 文件的整洁，可以用下面的方法”</p>
<p>第 1 步：把 <code>npm completion</code> 产生的那坨命令放在单独的文件中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm completion &gt;&gt; ~/.npm-completion.bash</div></pre></td></tr></table></figure>
<p>第 2 步，在 .bashrc 或者 .zshrc 中引入这个文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">echo &quot;[ -f ~/.npm-completion.bash ] &amp;&amp; source ~/.npm-completion.bash;&quot; &gt;&gt; ~/.bashrc</div><div class="line">echo &quot;[ -f ~/.npm-completion.bash ] &amp;&amp; source ~/.npm-completion.bash;&quot; &gt;&gt; ~/.zshrc</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>TIP</strong> ：执行完上面的命令一定要记得 <code>source ~/.zshrc</code> 或者 <code>source ~/.bashrc</code> ，来让自动完成生效。</p>
</blockquote>
<p>接下来我们就可以尽情享受自动补全带来的便利了，尝试在命令行中输入 <code>npm run</code> ，然后键入空格（空格很重要） , 然后键入 tab 键，发现命令行有什么反应了么？在列出备选项之后，继续按 tab，就能在不同的选项之间切换，找到自己想要的，直接回车就能完成命令补全。多练习几次，你的手指和大脑就能熟练找我这个过程。</p>
<p>在我们的项目目录里面键入 <code>npm run cov</code> 再键入 tab 键，命令行又有什么反应？</p>
<p>需要单独说明的是， <code>npm completion</code> 能实现的自动完成不仅仅是 scripts 里面的子命令，npm 的子命令也是可以的。</p>
<h4 id="更高级的自动完成"><a href="#更高级的自动完成" class="headerlink" title="更高级的自动完成"></a>更高级的自动完成</h4><p>人类对于效率的追求是永无止境的，工程师更是如此，npm 命令补全到目前为止显然还不够高效，能不能补全 package.json 里面的依赖名称？ 能不能在补全 npm script 的时候列出各个命令是干啥的？</p>
<p>有人已经帮我们解决了这个痛点，还写成了 zsh 插件（bash 的同学无福消受了）：<a href="https://github.com/lukechilds/zsh-better-npm-completion" target="_blank" rel="external">zsh-better-npm-completion</a>。它有几个让人无法拒绝的便利：</p>
<ol>
<li>在npm install 时自动根据历史安装过的包给出补全建议</li>
<li>在 npm uninstall 时候根据 package.json 里面的声明给出补全建议</li>
<li>在 npm run 时补全建议中列出命令细节</li>
</ol>
<p>看到这里，是不是心痒痒？具体安装方法参照官方 README.md 文件就好。这里就不啰嗦了。</p>
<blockquote>
<p><strong>TIP</strong> : 如果你要使用 zsh-better-npm-completion 插件，需要把 .bashrc、 .zshrc 文件里面的 npm completion 部分的配置删掉，避免冲突。</p>
</blockquote>
<h4 id="如何实现-yarn-的命令自动补全？"><a href="#如何实现-yarn-的命令自动补全？" class="headerlink" title="如何实现 yarn 的命令自动补全？"></a>如何实现 yarn 的命令自动补全？</h4><p>已经有人帮我们做好了 <a href="https://github.com/mklabs/yarn-completions" target="_blank" rel="external">yarn-completions</a> 。能实现类似于 zsh-better-npm-completion 的命令补全，参照官方 README.md 安装即可。</p>
<h1 id="高阶篇"><a href="#高阶篇" class="headerlink" title="高阶篇"></a>高阶篇</h1><h2 id="使用-npm-script-跨平台兼容"><a href="#使用-npm-script-跨平台兼容" class="headerlink" title="使用 npm script 跨平台兼容"></a>使用 npm script 跨平台兼容</h2><p>到目前位置，如果你在 Linux 、Mac 平台做开发，所有的 npm script 都会顺利运行，但是 windows 下面的同学可能就比较痛苦了，因为不是所有的 shell 命令都是跨平台兼容的，甚至各种常见的文件系统操作也是不兼容的。</p>
<p>可能有Buffer同学处理过 npm script 跨平台兼容问题，比如粗暴的为两种平台各写一份 npm script ，像下面这样：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attr">"name"</span>: <span class="string">"hello-npm-script"</span>,</div><div class="line">    <span class="attr">"scripts"</span>: &#123;</div><div class="line">        <span class="attr">"bash-script"</span>: <span class="string">"echo Hello $npm_package_name"</span>,</div><div class="line">        <span class="attr">"win-script"</span>: <span class="string">"echo Hello %npm_package_name%"</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有技术追求的工程师肯定不会满足上面的解决方案，实际上社区中已经有非常多的小工具可以帮我们优雅的实现跨平台的 npm script , 下面我们探索下如何实现跨平台的文件系统操作、变量引用、环境变量设置。</p>
<p><strong>特别说明， windows 环境的同学建议使用 git bash 来运行 npm script ,使用 windows 自带的 cmd 可能会遇到比较多的问题</strong></p>
<h3 id="文件系统操作的跨平台兼容"><a href="#文件系统操作的跨平台兼容" class="headerlink" title="文件系统操作的跨平台兼容"></a>文件系统操作的跨平台兼容</h3><p>npm script 中涉及到的文件系统操作包括文件和目录的创建、删除、移动、复制等操作，而社区也为基本操作提供了跨平台兼容的包，列举如下：</p>
<ul>
<li><code>rimraf</code> 或 <code>del-cli</code> ，用来删除文件或目录，实现类似于 <code>rm -rf</code> 的功能；</li>
<li><code>cpr</code> ，用于拷贝、复制文件和目录，实现类似于 <code>cp -r</code> 的功能</li>
<li><code>make-dir-cli</code> ，用于创建目录，实现类似于<code>mkdir -p</code> 的功能</li>
</ul>
<p>使用上面几个小工具改造 npm script 的具体步骤如下：</p>
<p>第 1 步，添加开发依赖：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">npm i rimraf cpr make-dir-cli -D</div><div class="line"><span class="meta">#</span> npm install rimraf cpr make-dir-cli --save-dev</div><div class="line"><span class="meta">#</span> yarn add rimraf cpr make-dir-cli -D</div></pre></td></tr></table></figure>
<p>第 2 步，改造设计文件系统操作的 npm script：</p>
<ul>
<li><p><code>rm -rf</code> 直接替换为 <code>rimraf</code>;</p>
</li>
<li><p><code>mkdir -p</code>直接替换成 <code>make-dir</code> ；</p>
</li>
<li><code>cp -r</code> 的替换需特别说明下，<code>cpr</code> 默认是不覆盖的，需要显式传入 <code>-o</code> 配置项，并且参数必须严格是<code>cpr &lt;source&gt; &lt;destination&gt; [options]</code> 的格式，即配置项放在最后面；</li>
<li>把  <code>cover:cleanup</code> 从 <code>postcover</code> 挪到 <code>precover</code> 里面去执行，规避 <code>cpr</code> 没归档完毕覆盖率报告就被清空的问题；</li>
</ul>
<h3 id="用-cross-var-引用变量"><a href="#用-cross-var-引用变量" class="headerlink" title="用 cross-var 引用变量"></a>用 cross-var 引用变量</h3><p>在前面介绍了如何使用内置的和预定义变量减少代码重复的技巧，如本节开头的例子, Linux 和 Windows 下引用变量的方式是不同的，Linux 下直接可以用 <code>$npm_package_name</code> ，而 Windows 下必须使用 <code>%npm_package_name%</code> ，我们可以使用 <code>cross-var</code> 实现跨平台的变量引用，具体步骤如下：</p>
<p>第 1 步: 安装 cross-var 为开发依赖：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">npm i cross-var -D</div><div class="line"><span class="meta">#</span> npm install cross-var --save-dev</div><div class="line"><span class="meta">#</span> yarn add cross-var -D</div></pre></td></tr></table></figure>
<p>第 2 步： 改写引用变量 npm script：</p>
<p>直接在原始命令前增加 <code>cross-var</code> 命令即可。<code>cover:archive</code> 内含了两条子命令，我们需要用引号把整个命令抱起来（注意这里是双引号，且必须转义），然后在前面加上 <code>cross-var</code></p>
<h3 id="用-cross-env-设置环境变量"><a href="#用-cross-env-设置环境变量" class="headerlink" title="用 cross-env 设置环境变量"></a>用 cross-env 设置环境变量</h3><p>在 node.js 脚本和 npm script 使用环境变量也是比较常见的，比如我们在运行测试时，需要加上 <code>NODE_ENV=test</code> ，或者在启动静态资源服务器时自定义端口号。因为不同平台的环境变量语法不同，我们可以使用 <code>cross-env</code> 来实现 npm script 的跨平台兼容，具体步骤如下：</p>
<p>第 1 步，添加 <code>cross-env</code> 到开发依赖：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">npm i cross-env -D</div><div class="line"><span class="meta">#</span> npm install cross-env --save-dev</div><div class="line"><span class="meta">#</span> yarn add cross-env -D</div></pre></td></tr></table></figure>
<p>第 2 步，改写使用环境变量的 npm script：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&quot;scripts&quot;: &#123;</div><div class="line">-    &quot;test&quot;: &quot;NODE_ENV=test mocha tests/&quot;,</div><div class="line">+    &quot;test&quot;: &quot;cross-env NODE_ENV=test mocha tests/</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的改动更简单，直接在设置了环境变量的命令前面加上 cross-env 即可。</p>
<h3 id="再多说几句"><a href="#再多说几句" class="headerlink" title="再多说几句"></a>再多说几句</h3><p>关于 npm script 的跨平台兼容，还有几点需要大家注意：</p>
<ul>
<li>所有使用引号的地方，建议使用双引号，并且加上转义；</li>
<li>没做特殊处理的命令比如 eslint、styleline、mocha、opn 等工具本身都是跨平台兼容的；</li>
<li>还是建议有能力的同学能使用 Linux 做开发，只要你入门并且熟练了，效率后提升惊人；</li>
<li>短时间继续拥抱 Windows 的同学，可以考虑看看 Windows 10 里面引入的 Subsytem ，让你不同虚拟机即可在 window 下使用大多数 Linux 命令。</li>
</ul>
<blockquote>
<p><strong>TIP</strong>：如果你在编写 npm script 过程中有更多的跨平台兼容需求，基本思路是去 <a href="https://link.juejin.im/?target=https%3A%2F%2Fwww.npmjs.com%2Fsearch%3Fq%3Dcross%2520platform" target="_blank" rel="external">npmjs.com</a> 上找对应的包，关键词自然少不了 <code>cross platform</code>，你遇到的问题，肯定很多其他人遇到过，相信我，你并不孤独！</p>
</blockquote>
<h3 id="把庞大的-npm-script-拆到单独文件中"><a href="#把庞大的-npm-script-拆到单独文件中" class="headerlink" title="把庞大的 npm script 拆到单独文件中"></a>把庞大的 npm script 拆到单独文件中</h3><p>当 npm script 不断累积、膨胀的时候，全部放在 package.json 里面可能并不是一个好主意，因为这样会导致 package.json糟乱，可读性降低。</p>
<p>借助 <code>scripty</code> 哦我们可以将 npm script 剥离到单独的文件中，从而把复杂性隔到单独的模块里面，让代码整体看起来更加清晰。</p>
<h3 id="用-node-js-脚本替代复杂的-npm-script"><a href="#用-node-js-脚本替代复杂的-npm-script" class="headerlink" title="用 node.js 脚本替代复杂的 npm script"></a>用 node.js 脚本替代复杂的 npm script</h3><p>Node.js 丰富的生态能赋予我们更强的能力，对于前端工程师来说，使用Node.js 来编写复杂的 npm script 具有明显的 2 个优势：首先，编写简单的工具脚本对前端工程师来说额外的学习成本很低甚至可以忽略不计，其次，因为 Node.js 本省是跨平台的，用它编写的脚本出现跨平台兼容问题的概率很小。</p>
<p>下面我们就一起来探索下，如何把上一节中使用 shell 编写的 cover 脚本改写成 Node.js 脚本，在 Node.js 脚本中我们也能体味到 <code>shelljs</code>这个工具包的强大。</p>
<h4 id="1-安装shelljs-依赖"><a href="#1-安装shelljs-依赖" class="headerlink" title="1. 安装shelljs 依赖"></a>1. 安装shelljs 依赖</h4><p>使用如下命令安装 shelljs 到项目依赖中：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">npm i shelljs -D</div><div class="line"><span class="meta">#</span> npm install shelljs --save-dev</div><div class="line"><span class="meta">#</span> yarn add shelljs -D</div></pre></td></tr></table></figure>
<p>此外，我们计划使用 <a href="https://link.juejin.im/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fchalk" target="_blank" rel="external">chalk</a> 来给输出加点颜色，让脚本变的更有趣，同样安装到 devDependencies 里面：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">npm i chalk -D</div><div class="line"><span class="meta">#</span> npm install chalk --save-dev</div><div class="line"><span class="meta">#</span> yarn add chalk -D</div></pre></td></tr></table></figure>
<h4 id="2-创建-Node-js-脚本"><a href="#2-创建-Node-js-脚本" class="headerlink" title="2. 创建 Node.js 脚本"></a>2. 创建 Node.js 脚本</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">touch scripts/cover.js</div></pre></td></tr></table></figure>
<h4 id="3-用-Node-js-实现同等功能"><a href="#3-用-Node-js-实现同等功能" class="headerlink" title="3. 用 Node.js 实现同等功能"></a>3. 用 Node.js 实现同等功能</h4><p>shelljs 为我们提供了各种常见命令的跨平台支持，比如 cp、mkdir、rm、cd 等命令，此外，理论上你可以在 Node.js 脚本中使用任何 <code>npmjs.com</code> 上能找到的包。清理归档目录、运行测试、归档并预览覆盖率报告的完整 Node.js 代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> &#123; rm, cp, mkdir, exec, echo &#125; = <span class="built_in">require</span>(<span class="string">'shelljs'</span>);</div><div class="line"><span class="keyword">const</span> chalk = <span class="built_in">require</span>(<span class="string">'chalk'</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(chalk.green(<span class="string">'1. remove old coverage reports...'</span>));</div><div class="line">rm(<span class="string">'-rf'</span>, <span class="string">'coverage'</span>);</div><div class="line">rm(<span class="string">'-rf'</span>, <span class="string">'.nyc_output'</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(chalk.green(<span class="string">'2. run test and collect new coverage...'</span>));</div><div class="line">exec(<span class="string">'nyc --reporter=html npm run test'</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(chalk.green(<span class="string">'3. archive coverage report by version...'</span>));</div><div class="line">mkdir(<span class="string">'-p'</span>, <span class="string">'coverage_archive/$npm_package_version'</span>);</div><div class="line">cp(<span class="string">'-r'</span>, <span class="string">'coverage/*'</span>, <span class="string">'coverage_archive/$npm_package_version'</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(chalk.green(<span class="string">'4. open coverage report for preview...'</span>));</div><div class="line">exec(<span class="string">'npm-run-all --parallel cover:serve cover:open'</span>);</div></pre></td></tr></table></figure>
<h4 id="4-让-package-json-指向新的脚本"><a href="#4-让-package-json-指向新的脚本" class="headerlink" title="4. 让 package.json 指向新的脚本"></a>4. 让 package.json 指向新的脚本</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">"scripts": &#123;</div><div class="line">    "cover": "node scripts/cover.js"</div><div class="line">&#125;</div></pre></td></tr></table></figure>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/node/" rel="tag"># node</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/09/27/react总览/" rel="next" title="react总览">
                <i class="fa fa-chevron-left"></i> react总览
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            Inhaltsverzeichnis
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Übersicht
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          
            <img class="site-author-image" itemprop="image"
              src="/images/avatar.png"
              alt="Ak-lee" />
          
            <p class="site-author-name" itemprop="name">Ak-lee</p>
            <p class="site-description motion-element" itemprop="description">start from zero</p>
        </div>

        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
            
              <a href="/archives/">
            
                <span class="site-state-item-count">28</span>
                <span class="site-state-item-name">Artikel</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">15</span>
                <span class="site-state-item-name">Tags</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#为什么选择-npm-script"><span class="nav-number">1.</span> <span class="nav-text">为什么选择 npm script?</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#初始-npm-script"><span class="nav-number">1.1.</span> <span class="nav-text">初始 npm script</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#用-npm-init-快速创建项目"><span class="nav-number">1.1.1.</span> <span class="nav-text">用 npm init 快速创建项目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用-npm-run-执行任意命令"><span class="nav-number">1.1.2.</span> <span class="nav-text">用 npm run 执行任意命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建自定义-npm-script"><span class="nav-number">1.1.3.</span> <span class="nav-text">创建自定义 npm script</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#eslint-完成-react、vue-js-代码的检查"><span class="nav-number">1.1.4.</span> <span class="nav-text">eslint 完成 react、vue.js 代码的检查</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#运行多个-npm-script-的各种姿势"><span class="nav-number">1.2.</span> <span class="nav-text">运行多个 npm script 的各种姿势</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#哪来那么多命令？"><span class="nav-number">1.2.1.</span> <span class="nav-text">哪来那么多命令？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#让多个-npm-script-串行？"><span class="nav-number">1.2.2.</span> <span class="nav-text">让多个 npm script 串行？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#让多个-npm-script-并行？"><span class="nav-number">1.2.3.</span> <span class="nav-text">让多个 npm script 并行？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#有没有更好的管理方式？"><span class="nav-number">1.2.4.</span> <span class="nav-text">有没有更好的管理方式？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#给-npm-script-传递参数和添加注释"><span class="nav-number">1.3.</span> <span class="nav-text">给 npm script 传递参数和添加注释</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#给-npm-script-传递参数"><span class="nav-number">1.3.0.1.</span> <span class="nav-text">给 npm script 传递参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#给-npm-script-添加注释"><span class="nav-number">1.3.0.2.</span> <span class="nav-text">给 npm script 添加注释</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#调整-npm-script-运行时日志输出"><span class="nav-number">1.3.1.</span> <span class="nav-text">调整 npm script 运行时日志输出</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#默认日志输出级别"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">默认日志输出级别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#显示尽可能少的有用信息"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">显示尽可能少的有用信息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#显示尽可能多的运行状态"><span class="nav-number">1.3.1.3.</span> <span class="nav-text">显示尽可能多的运行状态</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#进阶篇"><span class="nav-number">2.</span> <span class="nav-text">进阶篇</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#使用-npm-script-的钩子"><span class="nav-number">2.1.</span> <span class="nav-text">使用 npm script 的钩子</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#改造-test-命令"><span class="nav-number">2.1.1.</span> <span class="nav-text">改造 test 命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#增加覆盖率收集"><span class="nav-number">2.1.2.</span> <span class="nav-text">增加覆盖率收集</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#在-npm-script-中使用变量"><span class="nav-number">2.2.</span> <span class="nav-text">在 npm script 中使用变量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用预定义变量"><span class="nav-number">2.2.1.</span> <span class="nav-text">使用预定义变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用自定义变量"><span class="nav-number">2.2.2.</span> <span class="nav-text">使用自定义变量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实现命令行自动补全"><span class="nav-number">2.3.</span> <span class="nav-text">实现命令行自动补全</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#使用-npm-run-直接列出"><span class="nav-number">2.3.0.1.</span> <span class="nav-text">使用 npm run 直接列出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#把-npm-completion-集成到-shell-中"><span class="nav-number">2.3.0.2.</span> <span class="nav-text">把 npm completion 集成到 shell 中</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#更高级的自动完成"><span class="nav-number">2.3.0.3.</span> <span class="nav-text">更高级的自动完成</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何实现-yarn-的命令自动补全？"><span class="nav-number">2.3.0.4.</span> <span class="nav-text">如何实现 yarn 的命令自动补全？</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#高阶篇"><span class="nav-number">3.</span> <span class="nav-text">高阶篇</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#使用-npm-script-跨平台兼容"><span class="nav-number">3.1.</span> <span class="nav-text">使用 npm script 跨平台兼容</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#文件系统操作的跨平台兼容"><span class="nav-number">3.1.1.</span> <span class="nav-text">文件系统操作的跨平台兼容</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用-cross-var-引用变量"><span class="nav-number">3.1.2.</span> <span class="nav-text">用 cross-var 引用变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用-cross-env-设置环境变量"><span class="nav-number">3.1.3.</span> <span class="nav-text">用 cross-env 设置环境变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#再多说几句"><span class="nav-number">3.1.4.</span> <span class="nav-text">再多说几句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#把庞大的-npm-script-拆到单独文件中"><span class="nav-number">3.1.5.</span> <span class="nav-text">把庞大的 npm script 拆到单独文件中</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用-node-js-脚本替代复杂的-npm-script"><span class="nav-number">3.1.6.</span> <span class="nav-text">用 node.js 脚本替代复杂的 npm script</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-安装shelljs-依赖"><span class="nav-number">3.1.6.1.</span> <span class="nav-text">1. 安装shelljs 依赖</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-创建-Node-js-脚本"><span class="nav-number">3.1.6.2.</span> <span class="nav-text">2. 创建 Node.js 脚本</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-用-Node-js-实现同等功能"><span class="nav-number">3.1.6.3.</span> <span class="nav-text">3. 用 Node.js 实现同等功能</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-让-package-json-指向新的脚本"><span class="nav-number">3.1.6.4.</span> <span class="nav-text">4. 让 package.json 指向新的脚本</span></a></li></ol></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ak-lee</span>

  
</div>


  <div class="powered-by">Erstellt mit  <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.2</div>



<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
<span id="busuanzi_container_site_pv">
    |  您是本站第 <span id="busuanzi_value_site_pv"></span> 位访问者
</span>
        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>


  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  








  





  

  

  

  
  


  

  

</body>
</html>
